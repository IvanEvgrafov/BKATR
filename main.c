#include "pmlc_drv.h"

#include "math.h"


// Описание прерывания от таймера

void TIMER1_irq();

unsigned char INT0_REG;

#pragma interrupt 00 TIMER1_irq

#pragma locate INT0_REG 0x2000 noinit


// Описание прерывания от МКО

void IRQ_bsi();

#pragma interrupt 9 IRQ_bsi

unsigned char INT9_REG;

#pragma locate INT9_REG 0x2032 noinit

unsigned char p_mko;


unsigned char SYS_WDT_START;        // WDT
unsigned char SYS_WDT_REPEAT;       //

#pragma locate SYS_WDT_START 0xFC00 noinit
#pragma locate SYS_WDT_REPEAT 0xFC80 noinit


 // регистр доп упр
unsigned char SYS_OPT_CTRL_REG;

#pragma locate SYS_OPT_CTRL_REG 0xFE00 noinit

// используемые функции из других модулей

// считывание данных с АЦП (по канально)
extern unsigned short read_adc(unsigned char num_chan);

extern unsigned short read_adc_control(unsigned char num_chan);

// включение (отключение) заданного ТА
extern unsigned short on_ta(unsigned char num_ta);
extern unsigned short off_ta(unsigned char num_ta);

// процедура оключения всех нагревателей
extern void off_all_nag();

// процедуры перехода с контура на контур (включение нужного контура)
extern void kontur_g();
extern void kontur_h();

extern void otkl_kontur_g();
extern void otkl_kontur_h();
extern void analiz_vent_err();

extern void otkl_kont_g1();
extern void otkl_kont_h1();
extern void otkl_kont_g2();
extern void otkl_kont_h2();

extern void vkl_kont_g1();
extern void vkl_kont_h1();
extern void vkl_kont_g2();
extern void vkl_kont_h2();

extern void change_tm_1();
extern void change_tm_2();
extern void change_tm_3();
extern void change_tm_4();


// инициализация платы БАВ03
extern short init_bav03r();

// используемые переменные и структуры из других модулей

extern PMLC_CMD_LIST PMLC_TASK;

extern bav03r_type bav03r_N;
extern bta05r_type BTA05R_AN;
extern bta06r_type BTA06R_AN;

// задание и инициализация структуры состояния регистров устройства БЦВ03Р и БЦВ04Р

#pragma data_alignment=2
bcv03r_type BCV03R_N = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};

#pragma data_alignment=2
bcv04r_type BCV04R_N = {0x0,0x0,0x0,0x0,0x0};


// !!! ПЕРЕМЕННЫЕ ДЛЯ общей логики программы

// номер полукомплекта (определяется при старте программы)
unsigned char num_AB;

 // параметр - работа по КПА или ЦМ, по умолчанию КПА, потом, если от ЦМ есть спец. код, то переводим в ЦМ
unsigned char kpa_cm = 0;

// переменные управления включения автомат. режимов
//  по умолчанию авт. режимы выключены
unsigned char avt_mode1 = 0, avt_mode2 = 0;

// временный ручной режим при превышении допустимой разности между ТД1 и ТД2
unsigned char ruch_mode = 0;

// переменная - история БКА-ТР
unsigned char hist_tr, hist_tr_g = 0, hist_tr_h = 0;

// код текущего и последнего аварийного сообщения
unsigned char code_av = 0, code_av_last = 0;

// признак, что воздействие на ТА не проводилось, переменная обнуляется в начале каждого цикла
// в случае, если была команда ТА, отработка по сигналу, отказу, ОХК, ОГК, то значение равно 255
unsigned char ta_vozd = 0;

unsigned short count_ta_vozd = 0;


// !!! ПЕРЕМЕННЫЕ ДЛЯ РАБОТЫ С ПОСЛЕД. КАНАЛОМ

// статусный байт приёма-передатчика
unsigned char status_uart;

// переменная для ожидания данных по ЮАРТ
unsigned short delay_uart;

// переменные для приёма комманд
// номер блока, номер комманды, номер подтверждения комманды
unsigned char num_pm, num_com1;
unsigned char num_com = 255;

// последняя принятая команда
unsigned char last_command;


// !!! ПЕРЕМЕННЫЕ ДЛЯ РАБОТЫ С ТОКОВЫМИ АВТОМАТАМИ

// признак прихода новой команды на включение вентиляторов
unsigned char command_vent = 0;

// переменная выбора между Г и Х контурами при вызове соответствующей процедуры
unsigned char vent_gh, vent_gh_t;

// признак отключения ТА при использовании процедуры
unsigned char no_off_ta = 0;

// переменные для таймера по выполнению команд
unsigned char finish_25 = 0;
unsigned char tim_25 = 0;

unsigned short count_tim_25 = 0;

// переменные для таймера по температуре и ОХК, ОГК
unsigned char finish_25_t = 0;
unsigned char tim_25_t = 0;

unsigned short count_tim_25_t = 0;

// переменные для таймера по отказам
unsigned char finish_25_otk = 0;
unsigned char tim_25_otk = 0;

unsigned short count_tim_25_otk = 0;


// телем. переменные для считывания данных с ТА-портов
unsigned char tm_data_1, tm_data_2, tm_data_3, tm_data_4;
unsigned char tm_data_5, tm_data_6, tm_data_7, tm_data_8;

// вспомогательная переменная для работы с ток. автоматами
unsigned char ta_tm;


// !!! ПЕРЕМЕННЫЕ ДЛЯ РАБОТЫ С ОТКАЗАМИ и ГРАДУСАМИ

// значение сигналов отказов
unsigned char otkaz_data;

// переменные для блокировки вторичной обработки отказов с датчиков
unsigned char otk_g1 = 0, otk_g2 = 0, otk_h1 = 0, otk_h2 = 0;

// признаки увеличения счётчиков отказов и выполнения действий по их отработке
unsigned char g1_go = 0, g2_go = 0, h1_go = 0, h2_go = 0;

 // признаки отработки сигналов ОГК, ОХК
unsigned char ogk_go = 0, ohk_go = 0;

// переменные для счётчиков отказов
unsigned char  count_otk, count_otk_g = 0, count_otk_h = 0;

// Признаки отработки градусов: 23,14,5, 0, -10
// 0 - нет нужного градуса или он отработан
// 1 - нужно отробатывать нужный градус

unsigned char GR23 = 0, GR22_23 = 0, GR14_19 = 0, GR13_15 = 0, GR8_18 = 0;

// признаки отработки градусов (ТР2.3)
unsigned char GR26_27 = 0, GR20_19 = 0, GR19_18 = 0, GR18_17 = 0, GR24_25 = 0;

unsigned char GR5_X = 0, GR0_X = 0, GR10_X = 0, GR5_Y = 0, GR0_Y = 0, GR10_Y = 0;

// верхняя точка контроля температуры для вентиляторов, по умолчанию 26 градусов, по команде "Алг2" будет 27 градусов
unsigned char vent_max = 26;

// нижняя точка контроля температуры для вентиляторов, по умолчанию 20 градусов, по команде "Алг2" будет 19 градусов
unsigned char vent_min = 20;

// точка включения горячего нагревателя (по умолчанию 18), по "Алг2" - 17
unsigned char nagr_g = 18;

// точка включения горячего нагревателя (по умолчанию 19), по "Алг2" - 18
unsigned char nagr_h = 19;

// точка отключения нагревателей (по умолчанию 24), по "Алг2" - 25
unsigned char nagr_off = 24;


// !!! ПЕРЕМЕННЫЕ ДЛЯ РАБОТЫ с ТЕМПЕРАТУРОЙ

// вспомогательные переменные для преобразования температуры
unsigned char t, tips_td;

// аналоговое значение температуры анализируемого термодатчика
float t1;

 // режим работы термодатчиков
unsigned char mode_td = 0;

  // режимы 1-4 термодатчиков  - какой выбран, 1-3
unsigned char td1 = 1, td2 = 1, td3 = 1, td4 = 1;

 // состояние тройки термодатчиков, 0 - все 3 в работе, 1 - 1 отбракован, 2 - 2 отбраковано.
unsigned char state_tdd1 = 0, state_tdd2 = 0, state_tdd3 = 0, state_tdd4 = 0;

// переменная - признак неисправности одного из комплекта термодатчиков,
// при ней (значение 128) в ЦМ выдаётся специальное сообщение,
// по которому происходит переключение полукомплекта БКА-ТР
unsigned char privet = 0;

// массив условных кодов температуры от 0 до 198 (индексы температурной таблицы)
unsigned char cod_td[13];

// массив температур на термодатчиках
float t_td[13];

// массив признаков блокировки термодатчиков
unsigned char bl_td[13];

// массив признаков выходов термодатчиков за диапазон
unsigned char bums_td[13];

// преобразованная температура в спец. цифровом формате
unsigned char dig_td[2][13];

// массив номеров темодатчиков со сдвигом на один разряд влево
// (задаётся по умолчанию)
const unsigned char mas_num_td[13] = {2,4,6,10,12,14,18,20,22,26,28,30};

// 4, 2, 6, 20, 18, 22, 12, 10, 14, 28, 26, 30  - вариант с реверсом

// массив констант для телеметрии по отказам
const unsigned char mas_tm_otkaz[5] = {7,3,5,1,6};

// новое считываемое значение с термодатчика (переменная-буфер)
unsigned long new_data_td;

// опорное напряжение
float adc_contr;

// запрет на повторное определение неисправностей АЦП
unsigned char zap_av149 = 0;
unsigned char zap_av150 = 0;

// массив напряжений на термодатчиках
float u_td[13];



// ТАБЛИЦА Кодов Температуры

// 1 группа возможных значений, 0 - 15

// любое значение выше 4.285 - значит = -15
// диапазон 4.285-4.263  значит =-14.5 . и так далее

// таблица АЦП

const float table_u[200] = {
        4.285,          // -15 гр - 0
        4.263,
        4.242,          // -14 гр - 2
        4.221,
        4.199,          // -13 гр - 4
        4.176,
        4.154,          // -12 гр - 6
        4.130,
        4.106,          // -11 гр - 8
        4.082,
        4.057,          // -10 гр - 10
        4.033,
        4.007,          // -9 гр - 12
        3.981,
        3.955,          // -8 гр - 14
        3.929,
        3.903,          // -7 гр - 16
        3.875,
        3.848,          // -6 гр - 18
        3.819,
        3.790,          // -5 гр - 20
        3.760,
        3.730,          // -4 гр - 22
        3.701,
        3.671,          // -3
        3.641,
        3.611,          // -2
        3.579,
        3.547,          // -1
        3.515,
        3.490,          // 0
        3.479,
        3.459,          // 0.5
        3.443,
        3.426,          // 1
        3.409,
        3.392,          // 1.5
        3.374,
        3.358,          // 2
        3.341,
        3.323,          // 2.5
        3.306,
        3.288,          // 3
        3.270,
        3.253,          // 3.5
        3.237,
        3.219,          // 4
        3.201,
        3.183,          // 4.5
        3.164,
        3.145,          // 5
        3.128,
        3.110,          // 5.5
        3.092,
        3.074,          //  6
        3.055,
        3.037,          // 6.5
        3.018,
        2.999,          //  7
        2.980,
        2.961,          // 7.5

        2.942,
        2.923,    // 8
        2.904,
        2.888,    // 8.5
        2.873,
        2.852,    // 9
        2.830,
        2.812,    // 9.5
        2.794,
        2.772,    // 10
        2.752,
        2.732,    // 10.5
        2.711,
        2.692,    // 11
        2.673,
        2.653,    // 11.5
        2.632,
        2.611,    // 12
        2.590,
        2.571,    // 12.5
        2.550,
        2.529,    // 13
        2.509,
        2.488,    // 13.5
        2.468,
        2.444,    // 14
        2.427,
        2.405,    // 14.5
        2.385,
        2.363,    // 15

        2.342,
        2.321,   // 15.5
        2.301,
        2.280,   // 16
        2.258,
        2.237,   // 16.5
        2.216,
        2.195,   // 17
        2.172,
        2.149,   // 17.5
        2.128,
        2.106,   // 18
        2.086,
        2.064,   // 18.5
        2.042,
        2.021,   // 19
        1.999,
        1.977,   // 19.5
        1.955,
        1.933,   // 20
        1.912,
        1.890,   // 20.5
        1.868,
        1.845,   // 21
        1.824,
        1.803,   // 21.5
        1.780,
        1.757,   // 22
        1.734,
        1.712,   // 22.5

        1.690,
        1.668,   // 23
        1.645,
        1.623,   // 23.5
        1.599,
        1.578,   // 24
        1.556,
        1.533,   // 24.5
        1.512,
        1.490,   // 25
        1.467,
        1.444,   // 25.5
        1.421,
        1.399,   // 26
        1.377,
        1.355,   // 26.5
        1.333,
        1.310,   // 27
        1.288,
        1.265,   // 27.5

        1.242,
        1.220,   // 28
        1.198,
        1.175,   // 28.5
        1.152,
        1.130,   // 29
        1.107,
        1.085,   // 29.5
        1.063,
        1.040,   // 30
        1.017,
        0.995,   // 30.5
        0.972,
        0.948,   // 31
        0.926,
        0.904,   // 31.5
        0.880,
        0.859,   // 32
        0.838,
        0.815,   // 32.5

        0.792,
        0.770,   // 33
        0.749,
        0.727,   // 33.5
        0.704,
        0.681,   // 34
        0.659,
        0.637,   // 34.5
        0.615,
        0.594,   // 35
        0.572,
        0.548,   // 35.5
        0.526,
        0.504,   // 36
        0.482,
        0.460,   // 36.5
        0.438,
        0.416,   // 37
        0.394,
        0.372,   // 37.5

        0.350,
        0.329,   // 38
        0.307,
        0.285,   // 38.5
        0.264,
        0.242,   // 39
        0.220,
        0.199,   // 39.5
        0.178,
        0.156,   // 40
        0.135,
        0.114,   // 40.5
        0.094,
        0.072,   // 41
        0.050,
        0.028,   // 41.5
        0.016,
        0.000,   // 42
};


// !!! ПЕРЕМЕННЫЕ ДЛЯ отображения ТЕЛЕМЕТРИИ

// переменные для вывода телеметрии и тск наружу
unsigned char tm_1, tm_2, tm_3, tm_4;
unsigned char tsk_1, tsk_2;


// дополнительная телеметрия по вентиляторам
unsigned char tm_3_dop_g = 0;
unsigned char tm_3_dop_h = 0;

// переменные для сравнения и сохранения телеметрии
unsigned char tm_1_p = 0, tm_2_p = 0, tm_3_p = 0, tm_4_p = 0;
unsigned char tm_1_l = 0, tm_2_l = 0, tm_3_l = 0, tm_4_l = 0;

// признак первого опроса телеметрии и первого цикла
unsigned char first_vkl = 1;

// предыдущий кадр телеметрии
unsigned char save_frame = 1;

// текущий кадр телеметрии 1..7
// 1 - TD1, 2 - TD2, 3 - TD3, 4 - TD4, 5 - TA1, 6 - TA2, 7 - AVAR
unsigned char frame_tm = 1;

// значение текущего кадра в режиме полной телеметрии, принимает значения от 1..15, после чего
// происходит выход из режима полной телеметрии
unsigned char frame_pt = 1;

// счётчик количества кадров в режиме отработки изменений, от 1..12, после 12 происходит выход из режима
unsigned char count_mode3 = 0;

// признак срабатывания таймера нового кадра телеметрии
unsigned char change_tm = 0;

// режим отображения телеметрии
unsigned char mode_tm = 1;

// 1 - штатный режим, 6 показаний ( 4 + 2) каждый по 27 сек
// 2 - режим отработки изменений, 6 показаний (4+2) каждый по 5 сек

// 3 - 1 режим  авар. сооб., в течении  1мин каждые 5 сек меняются показания с ав.сообщ. на текущее штатное
// т.е., 5 (1 тд) + 5 (ав.) + 5 (2 тд.)....+ 5 (2 та) + 5 (ав.) = 60 сек.

// 4 - 2 режим авар.сооб., схема 27 + 5 = 27 сек (1 тд) + 5 сек. (ав.)...+ 27 (2 та) + 5 сек + 27 + 5...

// 5 - режим вывода только авар. сообщения
// 6 - режим полной телеметрии


// предшествующий текущему режим телеметрии
unsigned char last_mode_tm = 1;

// переменные для работы с таймером телеметрии
unsigned short count_timer = 0, timer_lim;

unsigned short timer27 = 614, timer5 = 114;

unsigned char alg = 0;



// !!! ПЕРЕМЕННЫЕ для управления КОНТУРАМИ

// переменная для процедур перехода с одного на другого вентиляторы
unsigned char tr;

// последний работающий автомат в контуре
unsigned char g_fix,h_fix;

// переменнst, показывающие какой ТА нужно включить при при вызове процедур kontur_g(), kontur_h().
unsigned char ta_g, ta_h;

// признаки получения команды ИСХ.ВЕНТ
unsigned char ish_g = 1;
unsigned char ish_h = 1;

// автомат, который нужно включить по команде
unsigned char g_com,h_com;

// !!! ПЕРЕМЕННЫЕ для МКО

// номера принятой и выдаваемой в ЦМ команды МКО
unsigned char mko_in_l, mko_in_h;
unsigned char mko_out_l, mko_out_h;

// признак прихода новой команды по МКО
unsigned char ch_mko = 0;

// буфер принятых команд по МКО
unsigned char mko_buf[2][90];

// счётчики принятых и отправленной в ЦМ команды МКО из приёмного буфера
unsigned char mko_buf_in = 0;
unsigned char mko_buf_out = 0;

//unsigned short msg_addr;

// переменные для обработки прерываний от МКО
volatile unsigned char bsi_int = 0;
volatile unsigned char bsi_int_cnt = 0;
volatile unsigned short bsi_rt_stat;

// транзитная информация БШВ
unsigned char bshv1 = 0;
unsigned char bshv2 = 0;
unsigned char bshv3 = 0;
unsigned char bshv4 = 0;

// переменная для оценки изменения данных БШВ
unsigned char bshv1_prev = 0;

// количество принятых сообщений
unsigned char c_msg_bshv = 0;
unsigned char c_msg_pc = 0;


// ПК по МКО
unsigned char prog_com = 0;

// ПК по МКО для ТМИ
unsigned char prog_com_tm = 0;

// последняя принятая внутренняя ПК
unsigned short last_pc = 0;

// последняя принятая и переданная транзитная ПК
unsigned short last_tr_in = 0;
unsigned short last_tr_out = 0;

// счётчики принятых и переданных транзитных ПК
unsigned char count_tr_in = 0;
unsigned char count_tr_out = 0;

// массив вывода телеметрии
unsigned short tmi[32];

// контрольная сумма ТМИ
unsigned long ks_tmi;


// флаг выполнения команды:
// 0 (00) - передана в ЦМ (для транзитных)
// 2048 (10) - принята, но не передача в ЦМ (для транзитных)
// 1024 (01) - выполнена (внутренняя)
// 3072 (11) - не выполнена (внутренняя)

unsigned short fl_com = 0;

unsigned char inf_bvm = 0;


void IRQ_bsi() //Interrupt of bsi
{
        __PUSHA();

       // ЗАПРЕЩАЕМ ПРЕРЫВАНИЯ
        __DI();

        bsi_int = 1;
        bsi_rt_stat = BSISTAT_TERM;
        bsi_int_cnt++;

                // РАЗРЕШАЕМ ПРЕРЫВАНИЯ

        __EI();
        __POPA();
}


// Обработка прерывания от таймера

void TIMER1_irq()
{
        __PUSHA();

       // ЗАПРЕЩАЕМ ПРЕРЫВАНИЯ
        __DI();


        // Обработка таймера телеметрии

        count_timer = count_timer + 1;

        // превышен временной порог срабатывания
        if (count_timer >= timer_lim)
        {
                // обнуление счётчика и установка признака смены ТМ кадра

                count_timer = 0;
                change_tm = 255;
        }

        // проверка таймера ожидания отключения ТА по РК

        if (tim_25 == 1)
        {
                count_tim_25 = count_tim_25 + 1;

                if (count_tim_25 > 650)
                {
                        // превышен допустимый предел

                        finish_25 = 1;
                }
        }


         // проверка таймера ожидания отключения ТА по ТД

        if (tim_25_t == 1)
        {
                count_tim_25_t = count_tim_25_t + 1;

                if (count_tim_25_t > 650)
                {
                        // превышен допустимый предел

                        finish_25_t = 1;
                }
        }

         // проверка таймера ожидания отключения ТА по отказам

        if (tim_25_otk == 1)
        {
                count_tim_25_otk = count_tim_25_otk + 1;

                if (count_tim_25_otk > 650)
                {
                        // превышен допустимый предел

                        finish_25_otk = 1;
                }
        }


        // РАЗРЕШАЕМ ПРЕРЫВАНИЯ

        __EI();
        __POPA();

        __NOP();
}



// процедура задержки на 7000 пустых циклов
void delay_7000()
{
        int c;

        c = 0;

        do{
        c = c + 1; }

        while(c < 7000) ;
}


// запуск режима телеметрии стандартного кадра по 27 секунд

void set_mode1()
{
        // сброс признака смены ТМ кадра
        change_tm = 0;

        // запоминаем предшествующий ТМ режим

        if (mode_tm != 1)
        {
                last_mode_tm = mode_tm;
        }

        // установка 1 - го ТМ режима
        mode_tm = 1;

        // перезапуск таймера с лимитом 27 секунд
        count_timer = 0;
        timer_lim = timer27;
}


// запуск телеметрии в режиме изменения - кадр по 5 секунд

void set_mode2()
{
        // вход в режим 2 только из режима 1,2 и 4

        if (mode_tm < 5)
        {
                // сброс признака смены ТМ кадра
                change_tm = 0;

                // запоминаем предшествующий ТМ режим если он изменился
                if (mode_tm != 2)
                {
                        last_mode_tm = mode_tm;
                }

                // установка 2 - го ТМ режима
                mode_tm = 2;

                // перезапуск таймера с лимитом 5 секунд
                count_timer = 0;
                timer_lim = timer5;
        }
}

// запуск режима полной телеметрии

void set_mode6()
{
        // сброс признака смены ТМ кадра
        change_tm = 0;

        // запоминаем предшествующий ТМ режим
        if (mode_tm != 6)
        {
                last_mode_tm = mode_tm;
        }

        // установка 6 - го ТМ режима
        mode_tm = 6;

        // перезапуск таймера с лимитом 5 секунд
        count_timer = 0;
        timer_lim = timer5;
}


// процедура добавления новой принятой команды МКО в буффер

void add_mko_buffer()
{
        // увеличение счётчика принятых команд

        mko_buf_in = mko_buf_in + 1;

        // добавление новой команды в буфер

        mko_buf[0][mko_buf_in - 1] = mko_in_h;
        mko_buf[1][mko_buf_in - 1] = mko_in_l;

        // при превышении допустимого числа в 90 осуществляется перезапись буфера с 0-го элемента

        if (mko_buf_in >= 90)
        {
                mko_buf_in = 0;
        }

        // признак добавления новой команды от МКО

        ch_mko = 1;
}



// процедура анализа разности показаний 1 тройки термодатчиков

void check_td_13()
{
        float delta_t12, delta_t13, delta_t23;

        // определяем величины разностей между ТД

        delta_t12 = fabs(t_td[0]-t_td[1]);
        delta_t13 = fabs(t_td[0]-t_td[2]);
        delta_t23 = fabs(t_td[1]-t_td[2]);

        // блок анализа для случая когда все 3 ТД находятся в работе

        if (state_tdd1 == 0)
        {
                // если ТД1 выходит за диапазон или разности между ТД1-ТД2 и ТД1-ТД3 больше 2

                if ((bums_td[0] == 255) || ((delta_t12 > 2) && (delta_t13 > 2)))
                {
                        // блокируем ТД1

                        if  (bl_td[0] != 255)
                        {
                                bl_td[0] = 255;

                                code_av = 137;
                        }

                        // Устанавливаем новое состояние ТД1-ТД3 (1 забракован)

                        state_tdd1 = 1;

                        // если были на ТД1, то переходим на ТД2

                        if (td1 == 1)
                        {
                                td1 = 2;
                        }

                        goto state_1_1;
                }

                // если ТД2 выходит за диапазон или разности между ТД1-ТД2 и ТД2-ТД3 больше 2

                if ((bums_td[1] == 255) || ((delta_t12 > 2) && (delta_t23 > 2)))
                {
                        // блокируем ТД2

                        if  (bl_td[1] != 255)
                        {
                                bl_td[1] = 255;

                                code_av = 138;
                        }

                        // Устанавливаем новое состояние ТД1-ТД3 (1 забракован)

                        state_tdd1 = 1;

                        // если были на ТД2, то переходим на ТД1

                        if (td1 == 2)
                        {
                                td1 = 1;
                        }

                        goto state_1_1;
                }

                // если ТД3 выходит за диапазон или разности между ТД1-ТД3 и ТД2-ТД3 больше 2

                if ((bums_td[2] == 255) || ((delta_t13 > 2) && (delta_t23 > 2)))
                {
                        // блокируем ТД3

                        if  (bl_td[2] != 255)
                        {
                                bl_td[2] = 255;

                                code_av = 139;
                        }

                        // Устанавливаем новое состояние ТД1-ТД3 (1 забракован)

                        state_tdd1 = 1;

                         // если были на ТД3, то переходим на ТД1

                        if (td1 == 3)
                        {
                                td1 = 1;
                        }
                }
        }

state_1_1:

        // блок анализа для случая когда все 1 ТД забракован

        if (state_tdd1 == 1)
        {
                // если забракован ТД1

                if (bl_td[0] == 255)
                {
                        // если разность между ТД2 и ТД3 больше 2-х или значения их выходят за диапазон

                        if ((delta_t23 > 2) || (bums_td[1] == 255) || (bums_td[2] == 255))
                        {
                                // блокируем 2 оставшихся термодатчика

                                if  (bl_td[1] != 255)
                                {
                                        bl_td[1] = 255;

                                        code_av = 138;
                                }

                                if  (bl_td[2] != 255)
                                {
                                        bl_td[2] = 255;

                                        code_av = 139;
                                }

                                // ставим новое состояние для тройки термодатчиков, дальше не анализируем её
                                state_tdd1 = 2;

                                // ставим признак смены полукомплекта
                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_1_2;
                        }
                }

                // если забракован ТД2

                if (bl_td[1] == 255)
                {
                        // если разность между ТД1 и ТД3 больше 2-х или значения их выходят за диапазон

                        if ((delta_t13 > 2) || (bums_td[0] == 255) || (bums_td[2] == 255))
                        {
                                // блокируем 2 оставшихся термодатчика

                                if  (bl_td[0] != 255)
                                {
                                        bl_td[0] = 255;

                                        code_av = 137;
                                }

                                if  (bl_td[2] != 255)
                                {
                                        bl_td[2] = 255;

                                        code_av = 139;
                                }

                                // ставим новое состояние для тройки термодатчиков, дальше не анализируем её
                                state_tdd1 = 2;

                                // ставим признак смены полукомплекта
                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_1_2;
                        }
                }

                // если забракован ТД3

                if (bl_td[2] == 255)
                {
                        // если разность между ТД1 и ТД3 больше 2-х или значения их выходят за диапазон

                        if ((delta_t12 > 2) || (bums_td[0] == 255) || (bums_td[1] == 255))
                        {
                                // блокируем 2 оставшихся термодатчика

                                if  (bl_td[0] != 255)
                                {
                                        bl_td[0] = 255;

                                        code_av = 137;
                                }

                                if  (bl_td[1] != 255)
                                {
                                        bl_td[1] = 255;

                                        code_av = 138;
                                }

                                // ставим новое состояние для тройки термодатчиков, дальше не анализируем её
                                state_tdd1 = 2;

                                // ставим признак смены полукомплекта
                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;
                        }
                }
        }

state_1_2:

        __NOP();

}


// процедура анализа показаний 2 тройки термодатчиков

void check_td_46()
{
        float delta_t45, delta_t46, delta_t56;

        // определяем величины разностей между ТД

        delta_t45 = fabs(t_td[3]-t_td[4]);
        delta_t46 = fabs(t_td[3]-t_td[5]);
        delta_t56 = fabs(t_td[4]-t_td[5]);

        // блок анализа для случая когда все 3 ТД находятся в работе

        if (state_tdd2 == 0)
        {
                // если ТД4 выходит за диапазон или разности между ТД4-ТД5 и ТД4-ТД6 больше 2

                if ((bums_td[3] == 255) || ((delta_t45 > 2) && (delta_t46 > 2)))
                {
                        // блокируем ТД4

                        if  (bl_td[3] != 255)
                        {
                                bl_td[3] = 255;

                                code_av = 140;
                        }

                        // Устанавливаем новое состояние ТД4-ТД6 (1 забракован)

                        state_tdd2 = 1;

                        // если были на ТД4, то переходим на ТД5

                        if (td2 == 1)
                        {
                                td2 = 2;
                        }

                        goto state_2_1;
                }


                if ((bums_td[4] == 255) || ((delta_t45 > 2) && (delta_t56 > 2)))
                {

                        if  (bl_td[4] != 255)
                        {
                                bl_td[4] = 255;

                                code_av = 141;
                        }

                        state_tdd2 = 1;

                        if (td2 == 2)
                        {
                                td2 = 1;
                        }

                        goto state_2_1;
                }


                if ((bums_td[5] == 255) || ((delta_t46 > 2) && (delta_t56 > 2)))
                {

                        if  (bl_td[5] != 255)
                        {
                                bl_td[5] = 255;

                                code_av = 142;
                        }

                        state_tdd2 = 1;

                        if (td2 == 3)
                        {
                                td2 = 1;
                        }
                }
        }


state_2_1:

        if (state_tdd2 == 1)
        {

                if (bl_td[3] == 255)
                {

                        if ((delta_t56 > 2) || (bums_td[4] == 255) || (bums_td[5] == 255))
                        {

                                if  (bl_td[4] != 255)
                                {
                                        bl_td[4] = 255;

                                        code_av = 141;
                                }

                                if  (bl_td[5] != 255)
                                {
                                        bl_td[5] = 255;

                                        code_av = 142;
                                }

                                state_tdd2 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_2_2;
                        }
                }


                if (bl_td[4] == 255)
                {

                        if ((delta_t46 > 2) || (bums_td[3] == 255) || (bums_td[5] == 255))
                        {

                                if  (bl_td[3] != 255)
                                {
                                        bl_td[3] = 255;

                                        code_av = 140;
                                }

                                if  (bl_td[5] != 255)
                                {
                                        bl_td[5] = 255;

                                        code_av = 142;
                                }

                                state_tdd2 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_2_2;
                        }
                }


                if (bl_td[5] == 255)
                {

                        if ((delta_t45 > 2) || (bums_td[3] == 255) || (bums_td[4] == 255))
                        {

                                if  (bl_td[3] != 255)
                                {
                                        bl_td[3] = 255;

                                        code_av = 140;
                                }

                                if  (bl_td[4] != 255)
                                {
                                        bl_td[4] = 255;

                                        code_av = 141;
                                }

                                state_tdd2 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;
                        }
                }
        }

state_2_2:

        __NOP();

}


// процедура анализа показаний 3 тройки термодатчиков

void check_td_79()
{
        float delta_t78, delta_t79, delta_t89;


        delta_t78 = fabs(t_td[6]-t_td[7]);
        delta_t79 = fabs(t_td[6]-t_td[8]);
        delta_t89 = fabs(t_td[7]-t_td[8]);


        if (state_tdd3 == 0)
        {

                if ((bums_td[6] == 255) || ((delta_t78 > 2) && (delta_t79 > 2)))
                {

                        if  (bl_td[6] != 255)
                        {
                                bl_td[6] = 255;

                                code_av = 143;
                        }

                        state_tdd3 = 1;

                        if (td3 == 1)
                        {
                                td3 = 2;
                        }

                        goto state_3_1;
                }


                if ((bums_td[7] == 255) || ((delta_t78 > 2) && (delta_t89 > 2)))
                {

                        if  (bl_td[7] != 255)
                        {
                                bl_td[7] = 255;

                                code_av = 144;
                        }

                        state_tdd3 = 1;

                        if (td3 == 2)
                        {
                                td3 = 1;
                        }

                        goto state_3_1;

                }

                if ((bums_td[8] == 255) || ((delta_t79 > 2) && (delta_t89 > 2)))
                {

                        if  (bl_td[8] != 255)
                        {
                                bl_td[8] = 255;

                                code_av = 145;
                        }

                        state_tdd3 = 1;

                        if (td3 == 3)
                        {
                                td3 = 1;
                        }
                }
        }


state_3_1:

        if (state_tdd3 == 1)
        {

                if (bl_td[6] == 255)
                {

                        if ((delta_t89 > 2) || (bums_td[7] == 255) || (bums_td[8] == 255))
                        {

                                if  (bl_td[7] != 255)
                                {
                                        bl_td[7] = 255;

                                        code_av = 144;
                                }

                                if  (bl_td[8] != 255)
                                {
                                        bl_td[8] = 255;

                                        code_av = 145;
                                }

                                state_tdd3 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_3_2;
                        }
                }


                if (bl_td[7] == 255)
                {

                        if ((delta_t79 > 2) || (bums_td[6] == 255) || (bums_td[8] == 255))
                        {

                                if  (bl_td[6] != 255)
                                {
                                        bl_td[6] = 255;

                                        code_av = 143;
                                }

                                if  (bl_td[8] != 255)
                                {
                                        bl_td[8] = 255;

                                        code_av = 145;
                                }

                                state_tdd3 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_3_2;
                        }
                }


                if (bl_td[8] == 255)
                {

                        if ((delta_t78 > 2) || (bums_td[6] == 255) || (bums_td[7] == 255))
                        {

                                if  (bl_td[6] != 255)
                                {
                                        bl_td[6] = 255;

                                        code_av = 143;
                                }

                                if  (bl_td[7] != 255)
                                {
                                        bl_td[7] = 255;

                                        code_av = 144;
                                }

                                state_tdd3 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;
                        }
                }
        }

state_3_2:

        __NOP();
}


// процедура анализа показаний 4 тройки термодатчиков

void check_td_1012()
{
        float delta_t10_11, delta_t10_12, delta_t11_12;


        delta_t10_11 = fabs(t_td[9]-t_td[10]);
        delta_t10_12 = fabs(t_td[9]-t_td[11]);
        delta_t11_12 = fabs(t_td[10]-t_td[11]);


        if (state_tdd4 == 0)
        {
                if ((bums_td[9] == 255) || ((delta_t10_11 > 2) && (delta_t10_12 > 2)))
                {

                        if  (bl_td[9] != 255)
                        {
                                bl_td[9] = 255;

                                code_av = 146;
                        }

                        state_tdd4 = 1;

                        if (td4 == 1)
                        {
                                td4 = 2;
                        }

                        goto state_4_1;
                }


                if ((bums_td[10] == 255) || ((delta_t10_11 > 2) && (delta_t11_12 > 2)))
                {

                        if  (bl_td[10] != 255)
                        {
                                bl_td[10] = 255;

                                code_av = 147;
                        }

                        state_tdd4 = 1;

                        if (td4 == 2)
                        {
                                td4 = 1;
                        }

                        goto state_4_1;
                }


                if ((bums_td[11] == 255) || ((delta_t10_12 > 2) && (delta_t11_12 > 2)))
                {

                        if  (bl_td[11] != 255)
                        {
                                bl_td[11] = 255;

                                code_av = 148;
                        }

                        state_tdd4 = 1;

                        if (td4 == 3)
                        {
                                td4 = 1;
                        }
                }
        }


state_4_1:

        if (state_tdd4 == 1)
        {

                if (bl_td[9] == 255)
                {

                        if ((delta_t11_12 > 2) || (bums_td[10] == 255) || (bums_td[11] == 255))
                        {

                                if  (bl_td[10] != 255)
                                {
                                        bl_td[10] = 255;

                                        code_av = 147;
                                }

                                if  (bl_td[11] != 255)
                                {
                                        bl_td[11] = 255;

                                        code_av = 148;
                                }

                                state_tdd4 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_4_2;
                        }
                }


                if (bl_td[10] == 255)
                {

                        if ((delta_t10_12 > 2) || (bums_td[9] == 255) || (bums_td[11] == 255))
                        {

                                if  (bl_td[9] != 255)
                                {
                                        bl_td[9] = 255;

                                        code_av = 146;
                                }

                                if  (bl_td[11] != 255)
                                {
                                        bl_td[11] = 255;

                                        code_av = 148;
                                }

                                state_tdd4 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;

                                goto state_4_2;
                        }
                }


                if (bl_td[11] == 255)
                {

                        if ((delta_t10_11 > 2) || (bums_td[9] == 255) || (bums_td[10] == 255))
                        {

                                if  (bl_td[9] != 255)
                                {
                                        bl_td[9] = 255;

                                        code_av = 146;
                                }

                                if  (bl_td[10] != 255)
                                {
                                        bl_td[10] = 255;

                                        code_av = 147;
                                }

                                state_tdd4 = 2;

                                privet = 128;

                                // возврат в ручной режим
                                mode_td = 0;
                        }
                }
        }

state_4_2:

        __NOP();
}




void main()
{
        // набор локальных вспомогательных переменных

        short i, io, ti;

        int d;

        float t_temp, p4;

        unsigned char tmp;

         __NOP();


        // определяем номер полукомплекта, 0 - А , 1 - Б

        tmp = WSR;
        WSR = tmp & 0x80;

        if ((IOPORT0 & 0x1) != 0)
        {
                num_AB = 1;
        }
        else
        {
                num_AB = 0;
        }

         // подключаем прием ПК

        SYS_OPT_CTRL_REG = num_AB + 1;


        // РАЗРЕШАЕМ ПРЕРЫВАНИЯ НА ПРОЦЕССОРЕ

        __EI();


        // по умолчанию предел таймера в 27 секунд

        timer_lim = timer27;

        // запуск таймера на 44 мс

        INT_MASK = 0x1;
        INT_MASK1 = 0x2;

        IOC1 = 0x27;

//        TIMER1 = ~0x05DE;

        //  инициализация UART

        tmp = WSR;                 //store WSR

//        WSR = (tmp & 0x80) | 0xF;  //swap to HWindow15
        WSR = (tmp & 0x80);        //swap to HWindow0

        __NOP();
        __NOP();

        SP_CON0 = 0x9;           // Mode = 1, Parity Bit = 0, Receive Enaible

        BAUD_RATE0 = 0x70;          //write Baud 2400 rate value
        BAUD_RATE0 = 0x82;

        __NOP();
        __NOP();

        WSR = tmp;                 //Restore HWindow


        // конфигурирование контроллера МКО:
        // - режим УТ
        // - ASK_DELAY=28 мкс
        // - SLOW=0 & Fxtal=24МГц -> DIV=24/4=6
        BSICONFIG = 0x5006;

        // регистр управления в режиме УТ:
        // TADDR=00029
        // TON=1 (включить контроллер!!!)
        // D10 = 1
        BSICON_TERM = 0xEC01;


            // инициализация МКО

        tmp = WSR;
        WSR = tmp & 0x80;

        p_mko = IOPORT1;

        p_mko = p_mko | 0x05;
        p_mko = p_mko & 0xF5;

        IOPORT1 = p_mko;

        WSR = tmp;

        __NOP();


        // выбор скорости передачи КС-ПМ                             `
        PMLC_baud_rate(R_12MBPS,  &PMLC_TASK);

        //--- разрешение на ввод/вывод данных по всем ОУ

        PMLC_select_device(NOM_PDEV, PDEV_4, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x3, &(BTA06R_AN.IO_CFG_REG));

        PMLC_select_device(RSV_PDEV, PDEV_4, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x30, &(BTA06R_AN.IO_CFG_REG));

        PMLC_select_device(NOM_PDEV, PDEV_3, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x1, &(BTA05R_AN.IO_CFG_REG));

        PMLC_select_device(NOM_PDEV, PDEV_2, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x1, &(BTA05R_AN.IO_CFG_REG));

        PMLC_select_device(RSV_PDEV, PDEV_2, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x10, &(BTA05R_AN.IO_CFG_REG));

        PMLC_select_device(RSV_PDEV, PDEV_3, &PMLC_TASK);
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x10, &(BTA05R_AN.IO_CFG_REG));


        //--- инициализация устройства БAВ03

        PMLC_select_device(NOM_PDEV, PDEV_0, &PMLC_TASK);
        init_bav03r(&PMLC_TASK, &bav03r_N);


        //--- инициализация устройства БЦВ03

        if (num_AB == 0)
        {
                PMLC_select_device(NOM_PDEV, PDEV_1, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(RSV_PDEV, PDEV_1, &PMLC_TASK);
        }

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x1F, &(BCV03R_N.IO_CFG_REG));



        //--- инициализация устройства БЦВ04

        if (num_AB == 0)
        {
                PMLC_select_device(RSV_PDEV, PDEV_1, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(NOM_PDEV, PDEV_1, &PMLC_TASK);
        }

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_CFG_REG, CMD_WRITE, 0x0, &(BCV04R_N.IO_CFG_REG));


        // рестарт WDT

        __DI();

        SYS_WDT_START = 0x3C;
        SYS_WDT_REPEAT = 0xA5;

        __EI();


        // сброс блокировки термодатчиков при старте программы

        for (i=0; i < 12; i++)
        {
                bl_td[i] = 0;
                bums_td[i] = 0;
        }


        // обнуляем приёмный буфер МКО

        for (io = 0; io <= 2; io++)
        {
                *(volatile unsigned short*)(0x842 + io) = 0;
        }

        // сначала переходим в выводу телеметрии

        goto output_tm;


Main_cycle:

        // рестарт WDT

        __DI();
        SYS_WDT_START = 0x3C;
        SYS_WDT_REPEAT = 0xA5;
        __EI();

                // если НЕ идёт процесс отключения вентилятора

        if ((tim_25 == 0) && (tim_25_t == 0) && (tim_25_otk == 0))
        {

                // при 4-х пустых циклах без обращения к ТА ставим признак для определения несанкционированного
                // включения(отключения) ТА

                if (ta_vozd == 255)
                {
                        count_ta_vozd = count_ta_vozd + 1;

                        if (count_ta_vozd > 5000)
                        {
                                ta_vozd = 0;

                                count_ta_vozd = 0;
                        }
                }
                else
                {
                        count_ta_vozd = 0;
                }
        }

        // проверяем наличие внутренних команд по МКО

        if (prog_com != 0)
        {
                num_com = prog_com - 1;

                prog_com = 0;

                fl_com = 2048;

                goto command_start;
        }



        //  обнуление параметра "время ожидания прихода данных по UART
        delay_uart = 0;


        // установка связи по ком-порту, получение параметров

        // проверка связи

        status_uart = SP_STAT0;

        if ((status_uart & 0x40) == 0)
        {
                goto otkl_ta_gh;
        }

Yes_uart_data:

         // номер блока

        num_pm = SBUF_RX0;
        __NOP();

        if (num_pm != 11)
        {

        // проверка служебных комманд

                // команда проверки наличия блока и определения номера полукомплекта

                if (num_pm == 120)
                {
                        kpa_cm = 1;

                        SBUF_TX0 = 85 + num_AB * 85;
                        __NOP();
                }


                // команда подтверждения по МКО (код 85)

                if ((num_pm & 0x05) == 0x05)
                {

                        // проверяем, что данные по сигналам корректны (нет одновременно 3-х сигналов)

                        if ((num_pm & 0x70) != 0x70)
                        {
                                inf_bvm = num_pm & 0xF0;
                        }



                        // если была добавлена новая команда от МКО

                        if (ch_mko == 1)
                        {
                                // посылаем условный код 85
                                SBUF_TX0 = 85;

                                delay_uart = 0;

                                // увеличиваем счётчик исходящих команд
                                mko_buf_out = mko_buf_out + 1;

                                // определяем код команды, который нужно отправить в ЦМ
                                mko_out_h = mko_buf[0][mko_buf_out - 1];
                                mko_out_l = mko_buf[1][mko_buf_out - 1];

                                // если достигли индекса 90, то переходим на 0 элемент таблицы
                                if (mko_buf_out >= 90)
                                {
                                        mko_buf_out = 0;
                                }

                                // как только количество принятых и выданных команд сравняется, то
                                // обнуляем признак необходимости посылки в ЦМ новой команды

                                if  (mko_buf_out == mko_buf_in)
                                {
                                        ch_mko = 0;
                                }

                                // посылка старшего байта команды
                        Send_h_mko:

                                status_uart = SP_STAT0;

                                if (( status_uart & 0x8) != 0)
                                {
                                        SBUF_TX0 = mko_out_h;
                                        __NOP();
                                }
                                else
                                {
                                        delay_uart = delay_uart + 1;
                                        __NOP();
                                        __NOP();

                                        if (delay_uart > 32000)
                                        {
                                                goto Fin_85;
                                        }

                                        goto Send_h_mko;
                                }

                                delay_uart = 0;

                                // посылка младшего байта команды

                        Send_l_mko:

                                status_uart = SP_STAT0;

                                if (( status_uart & 0x8) != 0)
                                {
                                        SBUF_TX0 = mko_out_l;

                                        __NOP();

                                        last_tr_out = 256 * mko_out_h + mko_out_l;

                                        count_tr_out ++;

                                        if (count_tr_out >= 64)
                                        {
                                                count_tr_out = 0;
                                        }

                                }
                                else
                                {
                                        delay_uart = delay_uart + 1;

                                        __NOP();
                                        __NOP();

                                        if (delay_uart > 32000)
                                        {
                                                delay_uart = 0;

                                                goto Fin_85;
                                        }

                                        goto Send_l_mko;
                                }

                        __NOP();

                        }
                        else
                        {
                               // если команда от МКО не поступала или уже всё было выдано ранее,
                               // то посылаем условный код 170

                                SBUF_TX0 = 170;
                        }

                Fin_85:

                        __NOP();
                }

                // служебная короткая команда с запросом счётчиков отказов и параметра типа алгоритма (1 или 2)

                if (num_pm == 112)
                {
                        count_otk = ((count_otk_h & 0x7) << 3) + (count_otk_g & 0x7);

                        // используемый алгоритм управления вентиляторами

                        if (alg == 1)
                        {
                                count_otk = count_otk + 64;
                        }

                        if (mode_td == 1)
                        {
                                count_otk = count_otk + 128;
                        }


                        SBUF_TX0 = count_otk;

                        __NOP();
                }

                // служебная короткая команда с запросом истории работы ТР + признак необходимости смены полукомплекта

                if (num_pm == 114)
                {
                        kpa_cm = 1;

                        hist_tr = privet + (avt_mode2 <<6 ) + (avt_mode1 << 4) + ((hist_tr_h & 0x3) << 2) + (hist_tr_g & 0x3);

                        SBUF_TX0 = hist_tr;

                        __NOP();
                }

                // команда специального режима измерения термодатчиков от КПА с передачей данных
                // по послед. порту

                if (num_pm == 45)
                {
                        SBUF_TX0 = 205;
                        __NOP();

                        goto Send12_td;
                }

                goto otkl_ta_gh;
        }


        // подтверждение номера блока

        status_uart = SP_STAT0;

        if (( status_uart & 0x8) != 0)
        {
                SBUF_TX0 = 11 + num_AB * 32;
                __NOP();
        }

        //  обнуление параметра "время ожидания прихода данных по UART
        delay_uart = 0;

delay_uart1:

        // номер комманды

        status_uart = SP_STAT0;

        if ((status_uart & 0x40) != 0)
        {
                goto receive_num_com;
        }

        delay_uart = delay_uart + 1;

        __NOP();
        __NOP();

        if (delay_uart > 30000)
        {
                goto otkl_ta_gh;
        }

        goto delay_uart1;


receive_num_com:

        num_com1 = SBUF_RX0;
        __NOP();


        // подтверждение номера комманды

        status_uart = SP_STAT0;

        if (( status_uart & 0x8) != 0)
        {
                SBUF_TX0 = num_com1;
                __NOP();
        }


        //  обнуление параметра "время ожидания прихода данных по UART
        delay_uart = 0;

delay_uart2:

        // номер комманды на исполнение

        status_uart = SP_STAT0;

        if ((status_uart & 0x40) != 0)
        {
                goto receive_num_com1;
        }

        delay_uart = delay_uart + 1;
        __NOP();
        __NOP();

        if (delay_uart > 30000)
        {
                goto otkl_ta_gh;
        }

        goto delay_uart2;

        // приём подтверждения исполнения команды

receive_num_com1:

        num_com = SBUF_RX0;
        __NOP();

        // запоминаем код последней команды
        last_command = num_com;

        // если подтверждение не равно коду команды
        // то дополнительный анализ для выделения служебных команд от ЦМ по приёму истории

        if (num_com1 != num_com)
        {
                // служебная команда 77 , счётчики отказов + алгоритм

                if (num_com1 == 77)
                {
                        // сбрасываем признаки отработки градусов

                        GR26_27 = 0;
                        GR20_19 = 0;
                        GR19_18 = 0;
                        GR18_17 = 0;
                        GR24_25 = 0;

                        if (num_com >= 128)
                        {
                                mode_td = 1;
                        }
                        else
                        {
                                mode_td = 0;
                        }

                        // определяем нужные уставки для температуры по каждому из алгоритмов

                        if (num_com >= 64)
                        {
                                alg = 1;

                                vent_max = 27;
                                vent_min = 19;
                                nagr_g = 17;
                                nagr_h = 18;
                                nagr_off = 25;
                        }
                        else
                        {
                                alg = 0;

                                vent_max = 26;
                                vent_min = 20;
                                nagr_g = 18;
                                nagr_h = 19;
                                nagr_off = 24;
                        }

                        // вычисляем счётчики отказов

                        count_otk_g = num_com & 0x7;

                        count_otk_h = (num_com >>3) & 0x7;
                }

                if (num_com1 == 78)
                {
                        // сбрасываем признаки исходного вентилятора

                        ish_g = 0;
                        ish_h = 0;

                        // определяем выбранный ТА

                        hist_tr_g = num_com & 0x3;

                        g_fix = 0x3 << (2 * hist_tr_g);

                        hist_tr_h = (num_com >> 2) & 0x3;

                        h_fix = 0x3 << (2 * hist_tr_h);

                        // определяем тип режима управления вентиляторами и нагревателями

                        avt_mode1 = (num_com >> 4) & 0x3;

                        avt_mode2 = (num_com >> 6) & 0x1;
                }

                goto sensor;
        }

        status_uart = SP_STAT0;

        // подтверждение исполнения комманды

        if (( status_uart & 0x8) != 0)
        {
                SBUF_TX0 = num_com1;
                __NOP();
        }

        // проверяем наличие проверочного режима

        if (num_com > 127)
        {
                // в проверочном режиме команды не выполняются

                goto sensor;
        }


command_start:

        // проверяем комманды на токовые автоматы

        if (num_com > 24)
        {
                ta_vozd = 255;

                goto select_ta;
        }

        // блок анализа внутренных комманд

internal_com:

        // авт. режим 1

        if (num_com == 0)
        {
                avt_mode1 = 3;

                if (alg == 0)
                {

                        // верхняя точка контроля температуры для вентиляторов = 26 градусов
                        vent_max = 26;

                        // нижняя точка контроля температуры для вентиляторов = 20 градусов
                        vent_min = 20;

                        // точка включения горячего нагревателя = 18
                        nagr_g = 18;

                        // точка включения холодного нагревателя = 19
                        nagr_h = 19;

                        // точка отключения нагревателей = 24
                        nagr_off = 24;
                }
                else
                {
                        // верхняя точка контроля температуры для вентиляторов = 27 градусов
                        vent_max = 27;

                        // нижняя точка контроля температуры для вентиляторов, по "Алг2" = 19 градусов
                        vent_min = 19;

                        // точка включения горячего нагревателя - по "Алг2" = 17
                        nagr_g = 17;

                        // точка включения холодного нагревателя - по "Алг2" = 18
                        nagr_h = 18;

                        // точка отключения нагревателей по "Алг2" = 25
                        nagr_off = 25;
                }


                // сброс блокировок от вторичной обработки по ТД

                GR26_27 = 0;
                GR20_19 = 0;
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                goto sensor;
        }

        // авт. режим 2

        if (num_com == 1)
        {
                avt_mode2 = 1;

                // сброс блокировок от вторичной обработки по ТД

                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                goto sensor;
        }

        // руч. режим 1

        if (num_com == 2)
        {
                avt_mode1 = 0;

                goto sensor;
        }

        // руч. режим 2

        if (num_com == 3)
        {
                avt_mode1 = 1;

                // верхняя точка контроля температуры для вентиляторов = 26 градусов
                vent_max = 26;

                // нижняя точка контроля температуры для вентиляторов = 20 градусов
                vent_min = 20;

                // сброс блокировок от вторичной обработки по ТД

                GR26_27 = 0;
                GR20_19 = 0;

                goto sensor;
        }


        // руч. режим 3

        if (num_com == 4)
        {
                avt_mode2 = 0;

                goto sensor;
        }


        // ТД1-1..3

        if ((num_com >= 5) && (num_com <= 7))
        {
                // Если не стоит автоматический режим, то выбираем ТД в первой тройке

                if (mode_td == 0)
                {
                        td1 = num_com - 4;
                }

                goto sensor;
        }

        // ТД2-1..3

        if ((num_com >= 8) && (num_com <= 10))
        {
                // Если не стоит автоматический режим, то выбираем ТД в второй тройке

                if (mode_td == 0)
                {
                        td2 = num_com - 7;
                }

                goto sensor;
        }

        // ТД3-1..3

        if ((num_com >= 11) && (num_com <= 13))
        {
                // Если не стоит автоматический режим, то выбираем ТД в третьей тройке

                if (mode_td == 0)
                {
                        td3 =  num_com - 10;
                }

                goto sensor;
        }

        // ТД4-1..3

        if ((num_com >= 14) && (num_com <= 16))
        {

                // Если не стоит автоматический режим, то выбираем ТД в четвёртой тройке

                if (mode_td == 0)
                {
                        td4 = num_com - 13;
                }

                goto sensor;
        }

        // РЕЖ ТМ1

        if (num_com == 17)
        {
                // выход из режима полной телеметрии и вхожение в обычный режим

                if (mode_tm == 6)
                {
                        set_mode1();

                        frame_pt = 1;
                }

                goto sensor;
        }


        // РЕЖ ТМ2

        if (num_com == 18)
        {
                // входим в режим полной телеметрии

                set_mode6();

                goto sensor;
        }

        // РЕЖ ТД1

        if (num_com == 19)
        {
                // установка режима ручного выбора ТД

                mode_td = 0;

                goto sensor;
        }

        // РЕЖ ТД2

        if (num_com == 20)
        {
                // установка режима автоматического выбора ТД

                if (mode_td != 1)
                {
                        mode_td = 1;

                        // сброс истории неисправностей ТД

                        for (i=0; i < 12; i++)
                        {
                                bl_td[i] = 0;
                        }

                        state_tdd1 = 0;
                        state_tdd2 = 0;
                        state_tdd3 = 0;
                        state_tdd4 = 0;

                        privet = 0;
                }

                goto sensor;
        }

        // Исх Вент

        if (num_com == 21)
        {
                // сброс истории неисправностей вентилятора

                count_otk_g = 0;
                count_otk_h = 0;

                ogk_go = 0;
                ohk_go = 0;

                // выбор первых вентиляторов

                ish_g = 1;
                ish_h = 1;

                g1_go = 0;
                g2_go = 0;
                h1_go = 0;
                h2_go = 0;

                GR26_27 = 0;
                GR20_19 = 0;
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                goto sensor;
        }

        // КОДС

        if (num_com == 22)
        {
                // если не в режиме полной телеметрии, то входим в режим постоянной выдачи авар. сообщения

                if (mode_tm != 6)
                {
                        // если уже в этом режиме, то старый режим пересохранять не нужно

                        if (mode_tm != 5)
                        {
                                last_mode_tm = mode_tm;
                        }

                        mode_tm = 5;
                }

                goto sensor;
        }

        // СКОДС

        if (num_com == 23)
        {
                // если не режим полной телеметрии, то выходим из аварийного режима и возврат в обычный по-кадровый режим

                if (mode_tm != 6)
                {
                        // сброс аварийного кода
                        code_av = 0;

                        // если текущий кадр аварийный, то выключаем его и переходим в обычный кадр

                        if (frame_tm == 7)
                        {
                                frame_tm = save_frame + 1;

                                if (frame_tm > 6)
                                {
                                        frame_tm = 1;
                                }
                        }
                        else
                        {
                                // если находимся в обычном кадре, то просто переходим на следующий

                                frame_tm = frame_tm + 1;

                                if (frame_tm > 6)
                                {
                                        frame_tm = 1;
                                }
                        }

                        // установка параметров первого режима ТМ

                        set_mode1();
                }

                goto sensor;
        }

        //              группа комманд по работе с ТА

select_ta:


        if ((count_otk_g < 4) && (count_otk_h < 4))
        {

                if ((num_com >=24) && (num_com <=28) && (num_com!= 26))
                {
                        if ((avt_mode1 != 0) && (t_td[2+td2] >= vent_max))
                        {
                                goto sensor;
                        }
                }

                if ((num_com >=29) && (num_com <=32))
                {
                        if ((avt_mode1 != 0) && (t_td[td1-1] <= vent_min))
                        {
                                goto sensor;
                        }
                }


        }

         // БДВ-Г1 ОК

        if (num_com == 24)
        {
// ставим признак команды включения горячего вентилятора

                vent_gh = 0;

                // обнуляем признак исходного вентилятора

                ish_g = 0;

                // проверяем включён ли Г1 ОК - если да, то ничего не делаем

                if ((tm_3 & 0x1) != 0)
                {
                        goto sensor;
                }

               // отключение Г1 РК, если это необходимо

                if ((tm_data_5 & 0xC) != 0)
                {
                        off_ta(18);
                }

                // отключение Г2 ОК, если это необходимо

                if ((tm_data_5 & 0x30) != 0)
                {
                        off_ta(19);
                }

                // отключение Г2 РК, если это необходимо

                if ((tm_data_5 & 0xC0) != 0)
                {
                        off_ta(20);
                }


                g_com = 0x3;

                command_vent = 1;

                goto otkl_ta_gh;

        }

        // БДВ-Г1 РК

        if (num_com == 25)
        {
                // ставим признак команды включения горячего вентилятора

                vent_gh = 0;

                // обнуляем признак исходного вентилятора

                ish_g = 0;

                // проверяем включён ли Г1 РК - если да, то ничего не делаем

                if ((tm_3 & 0x2) != 0)
                {
                        goto sensor;
                }

               // отключение Г1 ОК, если это необходимо

                if ((tm_data_5 & 0x3) != 0)
                {
                        off_ta(17);
                }

                // отключение Г2 ОК, если это необходимо

                if ((tm_data_5 & 0x30) != 0)
                {
                        off_ta(19);
                }

                // отключение Г2 РК, если это необходимо

                if ((tm_data_5 & 0xC0) != 0)
                {
                        off_ta(20);
                }

                command_vent = 1;

                g_com = 0xC;

                goto otkl_ta_gh;
        }

        // Откл. БДВ-Г2 РК

        if (num_com == 26)
        {

                if ((tm_data_5 & 0xC0) != 0)
                {
                        off_ta(20);

                        vent_gh = 2;

                        command_vent = 1;

                        g_com = 0x0;

                        goto otkl_ta_gh;
                }

                goto sensor;
        }


        // БДВ-Г2 ОК

        if (num_com == 27)
        {
                // ставим признак команды включения горячего вентилятора

                vent_gh = 0;

                // обнуляем признак исходного вентилятора

                ish_g = 0;


                if ((tm_3 & 0x4) != 0)
                {
                        goto sensor;
                }

               // отключение Г1 ОК, если это необходимо

                if ((tm_data_5 & 0x3) != 0)
                {
                        off_ta(17);
                }

                // отключение Г1 РК, если это необходимо

                if ((tm_data_5 & 0xC) != 0)
                {
                        off_ta(18);
                }

                // отключение Г2 РК, если это необходимо

                if ((tm_data_5 & 0xC0) != 0)
                {
                        off_ta(20);
                }

                command_vent = 1;

                g_com = 0x30;

                goto otkl_ta_gh;
        }


        // БДВ-Г2 РК

        if (num_com == 28)
        {

// ставим признак команды включения горячего вентилятора

                vent_gh = 0;

                // обнуляем признак исходного вентилятора

                ish_g = 0;

                if ((tm_3 & 0x8) != 0)
                {
                        goto sensor;
                }

                // отключение Г1 ОК, если это необходимо

                if ((tm_data_5 & 0x3) != 0)
                {
                        off_ta(17);

                }


                // отключение Г1 РК, если это необходимо

                if ((tm_data_5 & 0xC) != 0)
                {
                        off_ta(18);
                }


                // отключение Г2 ОК, если это необходимо

                if ((tm_data_5 & 0x30) != 0)
                {
                        off_ta(19);
                }

                command_vent = 1;

                g_com = 0xC0;

                goto otkl_ta_gh;

        }


        // БДВ-Х1 ОК

        if (num_com == 29)
        {
                // ставим признак команды включения холодного вентилятора

                vent_gh = 1;

                // обнуляем признак исходного вентилятора

                ish_h = 0;

                if ((tm_3 & 0x10) != 0)
                {
                        goto sensor;
                }

                // отключение Х1 РК, если это необходимо

                if ((tm_data_6 & 0xC) != 0)
                {
                        off_ta(22);
                }

                // отключение Х2 ОК, если это необходимо

                if ((tm_data_6 & 0x30) != 0)
                {
                        off_ta(23);
                }

                // отключение Х2 РК, если это необходимо

                if ((tm_data_6 & 0xC0) != 0)
                {
                        off_ta(24);
                }

                command_vent = 1;

                h_com = 0x3;

                goto otkl_ta_gh;
        }

        // БДВ-Х1 РК

        if (num_com == 30)
        {
                // ставим признак команды включения холодного вентилятора

                vent_gh = 1;

                // обнуляем признак исходного вентилятора

                ish_h = 0;

                if ((tm_3 & 0x20) != 0)
                {
                        goto sensor;
                }

                // отключение Х1 ОК, если это необходимо

                if ((tm_data_6 & 0x3) != 0)
                {
                        off_ta(21);
                }

                // отключение Х2 ОК, если это необходимо

                if ((tm_data_6 & 0x30) != 0)
                {
                        off_ta(23);
                }

                // отключение Х2 РК, если это необходимо

                if ((tm_data_6 & 0xC0) != 0)
                {
                        off_ta(24);
                }

                command_vent = 1;

                h_com = 0xC;

                goto otkl_ta_gh;
        }

        // БДВ-Х2 ОК

        if (num_com == 31)
        {
                // ставим признак команды включения холодного вентилятора

                vent_gh = 1;

                // обнуляем признак исходного вентилятора

                ish_h = 0;

                if ((tm_3 & 0x40) != 0)
                {
                        goto sensor;
                }

               // отключение Х1 ОК, если это необходимо

                if ((tm_data_6 & 0x3) != 0)
                {
                        off_ta(21);
                }

                // отключение Х1 РК, если это необходимо

                if ((tm_data_6 & 0xC) != 0)
                {
                        off_ta(22);
                }


                // отключение Х2 РК, если это необходимо

                if ((tm_data_6 & 0xC0) != 0)
                {
                        off_ta(24);
                }

                command_vent = 1;

                h_com = 0x30;

                goto otkl_ta_gh;
        }

        // БДВ-Х2 РК

        if (num_com == 32)
        {
                // ставим признак команды включения холодного вентилятора

                vent_gh = 1;

                // обнуляем признак исходного вентилятора

                ish_h = 0;

                if ((tm_3 & 0x80) != 0)
                {
                        goto sensor;
                }

                // отключение Х1 ОК, если это необходимо

                if ((tm_data_6 & 0x3) != 0)
                {
                        off_ta(21);
                }

                // отключение Х1 РК, если это необходимо

                if ((tm_data_6 & 0xC) != 0)
                {
                        off_ta(22);
                }

                // отключение Х2 ОК, если это необходимо

                if ((tm_data_6 & 0x30) != 0)
                {
                        off_ta(23);
                }

                command_vent = 1;

                h_com = 0xC0;

                goto otkl_ta_gh;
        }


com_num_33:

        // Блок выполнения обычных команд на ТА по общему принципу.
        // 1) проверка необходимости выполнения операции по телеметрии,
        // 2) отключение соседнего автомата, если необходимо (для команд на включение)
        // 3) включение заданного
        // 4) формируем аварийное сообщение, если операции завершены неудачно

        // ЦПОВ ОК

        if (num_com == 33)
        {
                if ((tm_2 & 0x20) != 0)
                {
                        if (off_ta(14) != 0)
                        {
                                code_av = 46;

                                goto output_tm;
                        }
                }

                if (on_ta(13) != 0)
                {
                        code_av = 13;
                }

                goto output_tm;
        }

        // ЦПОВ РК

        if (num_com == 34)
        {
                if ((tm_2 & 0x10) != 0)
                {
                        if (off_ta(13) != 0)
                        {
                                code_av = 45;

                                goto output_tm;
                        }
                }

                if (on_ta(14) != 0)
                {
                        code_av = 14;
                }

                goto output_tm;
        }

        // ЦПОВ ОТКЛ

        if (num_com == 35)
        {
                if ((tm_2 & 0x10) != 0)
                {
                        if (off_ta(13) != 0)
                        {
                                code_av = 45;
                        }
                }

                if ((tm_2 & 0x20) != 0)
                {
                        if (off_ta(14) != 0)
                        {
                                code_av = 46;
                        }
                }

                goto output_tm;
        }


       // ЭП1 ОК

        if (num_com == 36)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x2) != 0)
                {
                        if (off_ta(2) != 0)
                        {
                                code_av = 34;
                                goto output_tm;
                        }
                }

                if (on_ta(1) != 0)
                {
                        code_av = 1;
                }

                goto output_tm;
        }

        // ЭП1 РК

        if (num_com == 37)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x1) != 0)
                {
                        if (off_ta(1) != 0)
                        {
                                code_av = 33;
                                goto output_tm;
                        }
                }

                if (on_ta(2) != 0)
                {
                        code_av = 2;
                }

                goto output_tm;
        }


        // ЭП1 ОТКЛ

        if (num_com == 38)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x1) != 0)
                {
                        if (off_ta(1) != 0)
                        {
                                code_av = 33;
                        }
                }

                if ((tm_1 & 0x2) != 0)
                {
                        if (off_ta(2) != 0)
                        {
                                code_av = 34;
                        }
                }

                goto output_tm;
        }


        // ЭП2 ОК

        if (num_com == 39)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x8) != 0)
                {
                        if (off_ta(4) != 0)
                        {
                                code_av = 36;
                                goto output_tm;
                        }
                }

                if (on_ta(3) != 0)
                {
                        code_av = 3;
                }

                goto output_tm;
        }


        // ЭП2 РК

        if (num_com == 40)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x4) != 0)
                {
                        if (off_ta(3) != 0)
                        {
                                code_av = 35;

                                goto output_tm;
                        }
                }

                if (on_ta(4) != 0)
                {
                        code_av = 4;
                }

                goto output_tm;
        }


        // ЭП2 ОТКЛ

        if (num_com == 41)
        {
                // сброс запретов на повторную отработку по температуре

                GR5_X = 0;
                GR0_X = 0;
                GR10_X = 0;

                if ((tm_1 & 0x4) != 0)
                {
                        if (off_ta(3) != 0)
                        {
                                code_av = 35;
                        }
                }

                if ((tm_1 & 0x8) != 0)
                {
                        if (off_ta(4) != 0)
                        {
                                code_av = 36;
                        }
                }

                goto output_tm;
        }



       // ЭП3 ОК

        if (num_com == 42)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x20) != 0)
                {
                        if (off_ta(6) != 0)
                        {
                                code_av = 38;
                                goto output_tm;
                        }
                }

                if (on_ta(5) != 0)
                {
                        code_av = 5;
                }

                goto output_tm;
        }


        // ЭП3 РК

        if (num_com == 43)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x10) != 0)
                {
                        if (off_ta(5) != 0)
                        {
                                code_av = 37;
                                goto output_tm;
                        }
                }

                if (on_ta(6) != 0)
                {
                        code_av = 6;
                }

                goto output_tm;
        }

        // ЭП3 ОТКЛ

        if (num_com == 44)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x10) != 0)
                {
                        if (off_ta(5) != 0)
                        {
                                code_av = 37;
                        }
                }

                if ((tm_1 & 0x20) != 0)
                {
                        if (off_ta(6) != 0)
                        {
                                code_av = 38;
                        }
                }

                goto output_tm;
        }

        // ЭП4 ОК

        if (num_com == 45)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x80) != 0)
                {
                        if (off_ta(8) != 0)
                        {
                                code_av = 40;

                                goto output_tm;
                        }
                }

                if (on_ta(7) != 0)
                {
                        code_av = 7;
                }

                goto output_tm;
        }


        // ЭП4 РК

        if (num_com == 46)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x40) != 0)
                {
                        if (off_ta(7) != 0)
                        {
                                code_av = 39;
                                goto output_tm;
                        }
                }

                if (on_ta(8) != 0)
                {
                        code_av = 8;
                }

                goto output_tm;
         }

        // ЭП4 ОТКЛ

        if (num_com == 47)
        {
                // сброс запретов на повторную отработку по температуре
                GR5_Y = 0;
                GR0_Y = 0;
                GR10_Y = 0;

                if ((tm_1 & 0x40) != 0)
                {
                        if (off_ta(7) != 0)
                        {
                                code_av = 39;
                        }
                }

                if ((tm_1 & 0x80) != 0)
                {
                        if (off_ta(8) != 0)
                        {
                                code_av = 40;
                        }
                }

                goto output_tm;
        }

        // ВЭНХО

        if (num_com == 48)
        {
                // сброс запретов на повторную отработку по температуре
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                if ((tm_2 & 0x2) != 0)
                {
                        if (off_ta(10) != 0)
                        {
                                code_av = 42;
                                goto output_tm;
                        }
                }

                if (on_ta(9) != 0)
                {
                        code_av = 9;
                }

                goto output_tm;
        }


        // ВЭНХР

        if (num_com == 49)
        {
                // сброс запретов на повторную отработку по температуре
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                if ((tm_2 & 0x1) != 0)
                {
                        if (off_ta(9) != 0)
                        {
                                code_av = 41;
                                goto output_tm;
                        }
                }

                if (on_ta(10) != 0)
                {
                        code_av = 10;
                }

                goto output_tm;
        }


        // ВЭНГО

        if (num_com == 50)
        {
                // сброс запретов на повторную отработку по температуре
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                if ((tm_2 & 0x8) != 0)
                {
                        if (off_ta(12) != 0)
                        {
                                code_av = 44;
                                goto output_tm;
                        }
                }

                if (on_ta(11) != 0)
                {
                        code_av = 11;
                }

                goto output_tm;
        }

        // ВЭНГР

        if (num_com == 51)
        {
                // сброс запретов на повторную отработку по температуре
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                if ((tm_2 & 0x4) != 0)
                {
                        if (off_ta(11) != 0)
                        {
                                code_av = 43;
                                goto output_tm;
                        }
                }

                if (on_ta(12) != 0)
                {
                        code_av = 12;
                }

                goto output_tm;
        }

        // ОЭНХГ

        if (num_com == 52)
        {
                // сброс запретов на повторную отработку по температуре
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                off_all_nag();

                goto output_tm;
        }

        // БОКЗ - основной

        if (num_com == 53)
        {
                if ((tm_4 & 0x2) != 0)
                {
                        if (off_ta(26) != 0)
                        {
                                code_av = 56;
                                goto output_tm;
                        }
                }

                if (on_ta(25) != 0)
                {
                        code_av = 23;
                }

                goto output_tm;
        }

        // БОКЗ - резервный

        if (num_com == 54)
        {
                if ((tm_4 & 0x1) != 0)
                {
                        if (off_ta(25) != 0)
                        {
                                code_av = 55;
                                goto output_tm;
                        }
                }

                if (on_ta(26) != 0)
                {
                        code_av = 24;
                }

                goto output_tm;
        }

        // БОКЗ ОТКЛ

        if (num_com == 55)
        {
                if ((tm_4 & 0x1) != 0)
                {
                        if (off_ta(25) != 0)
                        {
                                code_av = 55;
                        }
                }

                if ((tm_4 & 0x2) != 0)
                {
                        if (off_ta(26) != 0)
                        {
                                code_av = 56;
                        }
                }

                goto output_tm;
        }

        // РСЧ ОК

        if (num_com == 56)
        {
                if ((tm_2 & 0x80) != 0)
                {
                        if (off_ta(28) != 0)
                        {
                                code_av = 62;
                                goto output_tm;
                        }
                }

                if (on_ta(27) != 0)
                {
                        code_av = 29;
                }

                goto output_tm;
        }

        // РСЧ РК

        if (num_com == 57)
        {
                if ((tm_2 & 0x40) != 0)
                {
                        if (off_ta(27) != 0)
                        {
                                code_av = 61;
                                goto output_tm;
                        }
                }

                if (on_ta(28) != 0)
                {
                        code_av = 30;
                }

                goto output_tm;
        }

        // РСЧ ОТКЛ

        if (num_com == 58)
        {
                if ((tm_2 & 0x40) != 0)
                {
                        if (off_ta(27) != 0)
                        {
                                code_av = 61;
                        }
                }

                if ((tm_2 & 0x80) != 0)
                {
                        if (off_ta(28) != 0)
                        {
                                code_av = 62;
                        }
                }

                goto output_tm;
        }

        // ЭНГГАК ОК

        if (num_com == 59)
        {
                if ((tm_4 & 0x80) != 0)
                {
                        if (off_ta(16) != 0)
                        {
                                code_av = 64;
                                goto output_tm;
                        }
                }

                if (on_ta(15) != 0)
                {
                        code_av = 31;
                }

                goto output_tm;
        }

        // ЭНГГАК РК

        if (num_com == 60)
        {
                if ((tm_4 & 0x40) != 0)
                {
                        if (off_ta(15) != 0)
                        {
                                code_av = 63;
                                goto output_tm;
                        }
                }

                if (on_ta(16) != 0)
                {
                        code_av = 32;
                }

                goto output_tm;
        }

        // ЭНГГАК ОТКЛ

        if (num_com == 61)
        {
                if ((tm_4 & 0x40) != 0)
                {
                        if (off_ta(15) != 0)
                        {
                                code_av = 63;
                        }
                }

                if ((tm_4 & 0x80) != 0)
                {
                        if (off_ta(16) != 0)
                        {
                                code_av = 64;
                        }
                }

                goto output_tm;
        }


        // ИКОР ОК

        if (num_com == 62)
        {

                if ((tm_4 & 0x8) != 0)
                {
                        if (off_ta(30) != 0)
                        {
                                code_av = 58;
                                goto output_tm;
                        }
                }

                if (on_ta(29) != 0)
                {
                        code_av = 25;
                }

                goto output_tm;

        }

        // ИКОР РК

        if (num_com == 63)
        {

                if ((tm_4 & 0x4) != 0)
                {
                        if (off_ta(29) != 0)
                        {
                                code_av = 57;

                                goto output_tm;
                        }
                }

                if (on_ta(30) != 0)
                {
                        code_av = 26;
                }

                goto output_tm;
        }

        // ИКОР ОТКЛ

        if (num_com == 64)
        {

                if ((tm_4 & 0x4) != 0)
                {
                        if (off_ta(29) != 0)
                        {
                                code_av = 57;
                        }
                }

                if ((tm_4 & 0x8) != 0)
                {
                        if (off_ta(30) != 0)
                        {
                                code_av = 58;
                        }
                }

                goto output_tm;
        }


        // РИМС ОК

        if (num_com == 65)
        {

                if ((tm_4 & 0x20) != 0)
                {
                        if (off_ta(32) != 0)
                        {
                                code_av = 60;
                                goto output_tm;
                        }
                }

                if (on_ta(31) != 0)
                {
                        code_av = 27;
                }

                goto output_tm;
        }


        // РИМС РК

        if (num_com == 66)
        {

                if ((tm_4 & 0x10) != 0)
                {
                        if (off_ta(31) != 0)
                        {
                                code_av = 59;
                                goto output_tm;
                        }
                }

                if (on_ta(32) != 0)
                {
                        code_av = 28;
                }

                goto output_tm;
        }


        // РИМС ОТКЛ

        if (num_com == 67)
        {
                if ((tm_4 & 0x10) != 0)
                {
                        if (off_ta(31) != 0)
                        {
                                code_av = 59;
                        }
                }

                if ((tm_4 & 0x20) != 0)
                {
                        if (off_ta(32) != 0)
                        {
                                code_av = 60;
                        }
                }

                goto output_tm;
        }



        // команда "Алгоритм 1"
        if (num_com == 68)
        {

                alg = 0;

                // верхняя точка контроля температуры для вентиляторов = 26 градусов
                vent_max = 26;

                // нижняя точка контроля температуры для вентиляторов = 20 градусов
                vent_min = 20;

                // точка включения горячего нагревателя = 18
                nagr_g = 18;

                // точка включения холодного нагревателя = 19
                nagr_h = 19;

                // точка отключения нагревателей = 24
                nagr_off = 24;

                // сбрасываем признаки отработки градусов

                GR26_27 = 0;
                GR20_19 = 0;
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                goto sensor;
        }

        // команда "Алгоритм 2"
        if (num_com == 69)
        {

                alg = 1;

                // верхняя точка контроля температуры для вентиляторов = 27 градусов
                vent_max = 27;

                // нижняя точка контроля температуры для вентиляторов, по "Алг2" = 19 градусов
                vent_min = 19;

                // точка включения горячего нагревателя - по "Алг2" = 17
                nagr_g = 17;

                // точка включения холодного нагревателя - по "Алг2" = 18
                nagr_h = 18;

                // точка отключения нагревателей по "Алг2" = 25
                nagr_off = 25;

                // сбрасываем признаки отработки градусов

                GR26_27 = 0;
                GR20_19 = 0;
                GR19_18 = 0;
                GR18_17 = 0;
                GR24_25 = 0;

                goto sensor;
        }

        // Служебные команды для установки счётчиков отказов с КПА

        if ((num_com >= 81) && (num_com <=84))
        {
                count_otk_g = num_com - 80;
        }


        if ((num_com >= 85) && (num_com <=88))
        {
                count_otk_h = num_com - 84;
        }

        // Служебные команды для установки выбранных ТА в контурах

        if ((num_com >= 89) && (num_com<=92))
        {
                g_fix = 0x3 << (2 * (num_com - 89));
        }


        if ((num_com >= 93) && (num_com<=96))
        {
                h_fix = 0x3 << (2 * (num_com - 93));
        }

// начальный этап выполнения команд по управлению вентиляторами

otkl_ta_gh:

        // проверяем признак выполнения команды

        if (command_vent != 0)
        {
                // если нет в текущий момент отработки по градусам и отказам,
                // приступаем к выполнению операции

                if ((tim_25_t == 0) && (tim_25_otk == 0))
                {
                        // сброс признака отработки команды

                        command_vent = 0;

                        // отключаем горячий контур, если он был включен и новая команда на холодный контур

                        if ((tm_data_5 != 0) && (vent_gh == 1))
                        {
                                otkl_kontur_g();
                        }

                        // отключаем холодный контур, если он был включен  и новая команда на горячий контур

                        if ((tm_data_6 != 0) && (vent_gh == 0))
                        {
                                otkl_kontur_h();
                        }

                        // запускаем таймер ожидания отключения ТА вентилятора
                        tim_25 = 1;
                        count_tim_25 = 0;
                        finish_25 = 0;

                        // установка признака воздействия на ТА
                        ta_vozd = 255;
                }
        }

// БЛОК ОПРОСА СОСТОЯНИЯ ТЕРМОДАТЧИКОВ

sensor:
        // выбор устройства АЦП

        PMLC_select_device(NOM_PDEV, PDEV_0, &PMLC_TASK);

        // ОПРОС АЦП

        __NOP();


           // определяем напряжение и температуру контрольного датчика АЦП1

  //     adc_contr = read_adc_control(14) * 5.0 * 1.004/ 4096;

       adc_contr = read_adc_control(14) * 5.0 * 1.012/ 4096 + 0.005;

       // в случае выхода значения за диапазон формируем аварийное сообщение "Ошибка АЦП1"

       if ((adc_contr < 1.1) || (adc_contr > 1.4))
       {
                if (zap_av149 == 0)
                {
                        zap_av149 = 1;

                        code_av = 149;
                }
       }
       else
       {
                zap_av149 = 0;
       }

           // определяем напряжение и температуру контрольного датчика АЦП2

  //     adc_contr = read_adc_control(15) * 5.0 * 1.004/ 4096;

        adc_contr = read_adc_control(15) * 5.0 * 1.012/ 4096 + 0.005;

       // в случае выхода значения за диапазон формируем аварийное сообщение "Ошибка АЦП2"

       if ((adc_contr < 1.1) || (adc_contr > 1.4))
       {
                if (zap_av150 == 0)
                {
                        zap_av150 = 1;

                        code_av = 150;
                }
       }
       else
       {
                zap_av150 = 0;
       }

       // в цикле от 1..12 опрашиваем каналы АЦП

        i = 0;

        while (i <= 11)
        {

                if ((i == 5) || (i == 10))
                {
                        status_uart = SP_STAT0;

                        if ((status_uart & 0x40) != 0)
                        {
                                goto Yes_uart_data;
                        }
                }

                // считываем цифровое значение

                new_data_td = read_adc(i);

        // определяем аналоговое напряжение и температуру датчика

       //         u_td[i] = new_data_td * 5.0 * 1.004/ 4096;

                u_td[i] = new_data_td * 5.0 * 1.012/ 4096 + 0.005;

       //         u_td[i] = new_data_td * 5.0 * 1.028/ 4096 + 0.012;

                // работаем с вспомогательной переменной

                p4 = u_td[i];

                // ДАЛЕЕ по таблице определяем нужный градус

                t_temp = 0;

                ti = 0;

                //   проверяем значения, которые меньше 0

                if (p4 > 3.515)
                {

                        while (ti < 29)
                        {
                                ti = ti + 1;

                                if (p4 <= table_u[29-ti])
                                {
                                        t_temp = -ti * 0.5;
                                        cod_td[i] = 30 - ti;

                                        goto save_t;
                                }

                                t_temp = - 15;
                                cod_td[i] =  0;

                        }

                        goto save_t;

                }
                else                // проверяем значения больше 0
                {
                        // разбиваем весь диапазон на 6 частей

                        if (p4 <= 2.98)
                        {
                                ti = 30;
                        }

                        if (p4 <= 2.395)
                        {
                                ti = 60;
                        }

                        if (p4 <= 1.734)
                        {
                                ti = 90;
                        }

                        if (p4 <= 1.063)
                        {
                                ti = 120;
                        }

                        if (p4 <= 0.394)
                        {
                                ti = 150;
                        }


                        while (ti < 169)
                        {
                                ti = ti + 1;

                                if (p4 > table_u[29+ti])
                                {
                                        goto determ_t;

                                }
                        }

                determ_t:

                        cod_td[i] =  29 + ti;
                        t_temp = 0.25 * (ti-1);
                }

        save_t:

                t_td[i] = t_temp;

                        // если температура выше 41 или ниже - 15 (больше 4.31 Вольт), то формируем признак
                        // выхода значений термодатчика за диапазон

                if ((t_temp > 41) || (p4 > 4.33))
                {
                        bums_td[i] = 255;
                }
                else
                {
                        bums_td[i] = 0;
                }

                i = i + 1;
        }

        // далее преобразуем эти значения в специальный код для выдачи значений ТД в телеметрию

        // формируем 2 байта данных для выдачи в телеметрию


        for (d=0; d < 12; d++)
        {

                dig_td[0][d] = mas_num_td[d];

                t1 = t_td[d];

                if (t1 < 0)
                {
                        t1 = fabs(t1);

                        t = t1;

                        t = t & 0x3F;

                        if ((t1-t) == 0)
                        {
                                t = t << 2;
                        }
                        else
                        {
                                t = t << 2;
                                t = t + 2;
                        }                                              }
                else
                {
                        t = t1;
                        t = t & 0x3F;

                        if ((t1 - t) == 0)
                        {
                                t = t << 2;
                        }

                        if ((t1 - t) == 0.25)
                        {
                                t = t << 2;
                                t = t + 1;
                        }

                        if ((t1 - t) == 0.5)
                        {
                                t = t << 2;
                                t = t + 2;
                        }
                        if ((t1 - t) == 0.75)
                        {
                                t = t << 2;
                                t = t + 3;
                        }

                        dig_td[0][d] = dig_td[0][d] + 1;
                }

                // добавляем туда телеметрические параметры

                if (bl_td[d] != 255)
                {
                        dig_td[0][d] = dig_td[0][d] + 0x40;
                }

                if (mode_td == 0)
                {
                        dig_td[0][d] = dig_td[0][d] + 0x80;
                }


                dig_td[0][d] = dig_td[0][d] + 0x20;

                dig_td[1][d] = t;

        }

        // устанавливаем признак выбранного ТД

        dig_td[0][td1-1] = dig_td[0][td1-1] - 0x20;
        dig_td[0][2 + td2] = dig_td[0][2 + td2] - 0x20;
        dig_td[0][5 + td3] = dig_td[0][5 + td3] - 0x20;
        dig_td[0][8 + td4] = dig_td[0][8 + td4] - 0x20;

        // формируем 3 байт - тип ТМ сообщения

        if (ruch_mode == 1)
        {
                tips_td = 4 + avt_mode2;
        }
        else
        {
                // авт. режим

                if (avt_mode1 == 3)
                {
                        tips_td = 6 + avt_mode2;
                }

                // Ручной 1

                if (avt_mode1 == 0)
                {
                        tips_td = 4 + avt_mode2;
                }

                // Ручной 2

                if (avt_mode1 == 1)
                {
                        tips_td = 2 + avt_mode2;
                }
        }

// проверка режима автоматической отбраковки неисправных термодатчиков

check_td:

        // если режимм автоматической смены ТД включён и нет забракованных троек,
        // то входим в анализ состояния ТД и разности их показаний


        if (mode_td == 1)
        {

                status_uart = SP_STAT0;

                if ((status_uart & 0x40) != 0)
                {
                        goto Yes_uart_data;
                }


                // для каждой тройки ТД вызывается своя процедура

                if (state_tdd1 < 2)
                {
                        check_td_13();
                }

                if (state_tdd2 < 2)
                {
                        check_td_46();
                }

                if (state_tdd3 < 2)
                {
                        check_td_79();
                }

                if (state_tdd4 < 2)
                {
                        check_td_1012();
                }
        }

        // проверка режима автоматического управления гермоотсеком по температуре

auto_mode_1:


        if (avt_mode1 != 0)
        {

                status_uart = SP_STAT0;

                if ((status_uart & 0x40) != 0)
                {
                        goto Yes_uart_data;
                }


                // проверяем, что разница между ТД1 и ТД2 не превышает допустимого значения для 2-х разных режимов
                // а также, что ТД2 достиг верхнего порога срабатывания

                // условие для АЛГ2

                if (vent_min == 19)
                {
                        if ((fabs(t_td[2+td2] - t_td[td1-1]) > 7.5) && (t_td[2+td2] >= 27))
                        {
                                ruch_mode = 1;

                                code_av = 153;

                                goto auto_mode_2;
                        }
                        else
                        {
                                ruch_mode = 0;
                        }
                }
                else
                {
                        // условие для АЛГ1

                        if ((fabs(t_td[2+td2] - t_td[td1-1]) > 5.5) && (t_td[2+td2] >= 26))
                        {
                                ruch_mode = 1;

                                code_av = 153;

                                goto auto_mode_2;
                        }
                        else
                        {
                                ruch_mode = 0;
                        }
                }


                // если ОХК или ОГК, то управление вентиляторов по градусам блокируется

                if (count_otk_g >= 4)
                {
                        goto auto_mode_1_nagr;
                }

                if (count_otk_h >= 4)
                {
                        goto auto_mode_1_nagr;
                }



                if (num_AB == 0)
                {
                        PMLC_select_device(NOM_PDEV, PDEV_3, &PMLC_TASK);
                }
                else
                {
                        PMLC_select_device(RSV_PDEV, PDEV_3, &PMLC_TASK);
                }

                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
                tm_data_5 = ~BTA05R_AN.IO_PORT_2;


                if (num_AB == 0)
                {
                        PMLC_select_device(NOM_PDEV, PDEV_2, &PMLC_TASK);
                }
                else
                {
                        PMLC_select_device(RSV_PDEV, PDEV_2, &PMLC_TASK);
                }


                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
                tm_data_6 = ~BTA05R_AN.IO_PORT_2;



                // отработка по 20 или 19 градусам  - минимальная граница диапазона вентиляторов

                if (t_td[td1-1] <= vent_min)
                {
                        // если достигнута нижняя граница температуры
                        // то переходим на горячий контур

                        // если уже проводится отключение вентилятора, то сначала дожидаемся окончания операции

                        if ((tim_25 == 0) && (tim_25_t == 0)  && (tim_25_otk == 0))
                        {
                                // проверка от повторной отработки

                                if (GR20_19 == 0)
                                {
                                        // ставим признак воздействия на ТА

                                        ta_vozd = 255;

                                        // сперва отключаем холодный контур

                                        if (tm_data_6 != 0)
                                        {
                                                otkl_kontur_h();
                                        }

                                        // включаем горячий контур

                                        if (tm_data_5 == 0)
                                        {
                                                vent_gh_t = 0;

                                                tim_25_t = 1;
                                                count_tim_25_t = 0;
                                                finish_25_t = 0;
                                        }

                                // ставим признак запрета от вторичного выполнения операции

                                        GR20_19 = 1;
                                }
                        }
                }
                else
                {
                        // если нижняя граница не достигнута, то запрет от вторичной отработки обнуляется
                        GR20_19 = 0;
                }


                // отработка вентиляторов по 26 или 27 градусам - верхняя граница вентиляторов

                if (t_td[2+td2] >= vent_max)
                {

                        // если достигнута верхняя граница температуры в 23 градуса
                        // то переходим на горячий контур

                        // если уже проводится отключение вентилятора, то сначала дожидаемся окончания операции

                        if ((tim_25 == 0) && (tim_25_t == 0) && (tim_25_otk == 0))
                        {
                                // проверка от повторной отработки

                                if (GR26_27 == 0)
                                {
                                        // ставим признак воздействия на ТА

                                        ta_vozd = 255;

                                        // сперва отключаем горячий контур

                                        if (tm_data_5 != 0)
                                        {
                                                otkl_kontur_g();
                                        }

                                        // включаем холодный контур

                                        if (tm_data_6 == 0)
                                        {
                                                vent_gh_t = 1;

                                                tim_25_t = 1;
                                                count_tim_25_t = 0;
                                                finish_25_t = 0;
                                        }

                                        // ставим признак запрета от вторичного выполнения операции

                                        GR26_27 = 1;
                                }
                        }
                }
                else
                {
                        // если нижняя граница не достигнута, то запрет от вторичной отработки обнуляется
                        GR26_27 = 0;
                }


auto_mode_1_nagr:

                // проверка автоматического режима нагревателей

                if (avt_mode1 == 3)
                {

                        // включение горячих нагревателей по 18 или 17 градусам

                        if (t_td[td1-1] <= nagr_g)
                        {
                                // проверка на первичное выполнение операции

                                if (GR18_17 == 0)
                                {
                                        // включаем горячие нагреватели

                                        if ((tm_2 & 0xC) == 0)
                                        {
                                                if (on_ta(11) != 0)
                                                {
                                                        code_av = 11;

                                                        if (on_ta(12) != 0)
                                                        {
                                                                code_av = 12;
                                                        }
                                                }

                                                // признак воздействия на ТА

                                                ta_vozd = 255;
                                        }

                                        // признак запрета вторичного выполнения операции
                                        GR18_17 = 1;
                                }
                        }
                        else
                        {
                                // сброс признак запрета вторичного выполнения операции
                                GR18_17 = 0;
                        }


                        // включение холодных нагревателей по 19 или 18 градусам

                        if (t_td[td1-1] <= nagr_h)
                        {
                                // проверка первичности выполнения операции

                                if (GR19_18 == 0)
                                {
                                        // включаем холодные нагреватели

                                        if ((tm_2 & 0x3) == 0)
                                        {
                                                if (on_ta(9) != 0)
                                                {
                                                        code_av = 9;

                                                        if (on_ta(10) != 0)
                                                        {
                                                                code_av = 10;
                                                        }
                                                }

                                                // признак воздействия

                                                ta_vozd = 255;
                                        }

                                        // блоикровка от повторного выполнения
                                        GR19_18 = 1;
                                }
                        }
                        else
                        {
                                // снятие блокировки повторного выполнения
                                GR19_18 = 0;
                        }


                        // отключение нагревателей по 24 или 25 градусам

                        if (t_td[2+td2] >= nagr_off)
                        {
                                // проверка на первичность выполнения операции

                                if (GR24_25 == 0)
                                {
                                        // процедура отключения всех нагревателей

                                        if ((tm_2 & 0xF) != 0)
                                        {
                                                off_all_nag();

                                                ta_vozd = 255;
                                        }

                                        // блокировка от повторной отработки

                                        GR24_25 = 1;
                                }
                        }
                        else
                        {
                                // снятие блокировки от повторной отработки

                                GR24_25 = 0;
                        }
                }
        }

        // БЛОК анализа автомтического управления платформой

auto_mode_2:

        if (avt_mode2 != 0)
        {

                // ось Х

                // отработка по 0 градусам

                if (t_td[5+td3] <= 0)
                {
                        // проверка на запрет

                        if (GR0_X == 0)
                        {

                                // включаем ЭП1

                                if ((tm_1 & 0x3) == 0)
                                {
                                        if (on_ta(1) != 0)
                                        {
                                                code_av = 1;

                                                if (on_ta(2) != 0)
                                                {
                                                        code_av = 2;
                                                }
                                        }

                                        // признак воздействия на ТА

                                        ta_vozd = 255;
                                }

                                GR0_X = 1;
                        }
                }
                else
                {
                        GR0_X = 0;
                }


                // отработка по -10 градусам

                if (t_td[5+td3] <= -10)
                {
                        if (GR10_X == 0)
                        {

                                // включаем ЭП2

                                if ((tm_1 & 0xC) == 0)
                                {

                                        if (on_ta(3) != 0)
                                        {
                                                code_av = 3;

                                                if (on_ta(4) != 0)
                                                {
                                                        code_av = 4;
                                                }
                                        }

                                        ta_vozd = 255;
                                }

                                GR10_X = 1;
                        }
                }
                else
                {
                        GR10_X = 0;
                }

                // отработка по 5 градусам

                if (t_td[5+td3] >= 5)
                {
                        if (GR5_X == 0)
                        {

                                ta_vozd = 255;

                                // отключаем ЭП1, ЭП2

                                if ((tm_1 & 0x1) != 0)
                                {
                                        if (off_ta(1) != 0)
                                        {
                                                code_av = 33;
                                        }
                                }

                                if ((tm_1 & 0x2) != 0)
                                {
                                        if (off_ta(2) != 0)
                                        {
                                                code_av = 34;
                                        }
                                }


                                if ((tm_1 & 0x4) != 0)
                                {
                                        if (off_ta(3) != 0)
                                        {
                                                code_av = 35;
                                        }
                                }

                                if ((tm_1 & 0x8) != 0)
                                {
                                        if (off_ta(4) != 0)
                                        {
                                                code_av = 36;
                                        }
                                }

                                GR5_X = 1;
                        }
                }
                else
                {
                        GR5_X = 0;
                }

                // ось Y

                // отработка по 0 градусам

                if (t_td[8+td4] <= 0)
                {
                        if (GR0_Y == 0)
                        {
                                // включаем ЭП3

                                if ((tm_1 & 0x30) == 0)
                                {

                                        ta_vozd = 255;

                                        if (on_ta(5) != 0)
                                        {
                                                code_av = 5;

                                                if (on_ta(6) != 0)
                                                {
                                                        code_av = 6;
                                                }
                                        }
                                }

                                GR0_Y = 1;
                        }
                }
                else
                {
                        GR0_Y = 0;
                }

                        // отработка по -10 градусам

                if (t_td[8+td4] <= -10)
                {
                        if (GR10_Y == 0)
                        {

                                // включаем ЭП4

                                if ((tm_1 & 0xC0) == 0)
                                {

                                        ta_vozd = 255;

                                        if (on_ta(7) != 0)
                                        {
                                                code_av = 7;

                                                if (on_ta(8) != 0)
                                                {
                                                        code_av = 8;
                                                }
                                        }
                                }

                                GR10_Y = 1;
                        }
                }
                else
                {
                        GR10_Y = 0;
                }


                        // отработка по 5 градусам

                if (t_td[8+td4] >= 5)
                {
                        if (GR5_Y == 0)
                        {

                                ta_vozd = 255;

                                if ((tm_1 & 0x10) != 0)
                                {
                                        if (off_ta(5) != 0)
                                        {
                                                code_av = 37;
                                        }
                                }

                                if ((tm_1 & 0x20) != 0)
                                {
                                        if (off_ta(6) != 0)
                                        {
                                                code_av = 38;
                                        }
                                }


                                if ((tm_1 & 0x40) != 0)
                                {
                                        if (off_ta(7) != 0)
                                        {
                                                code_av = 39;
                                        }
                                }

                                if ((tm_1 & 0x80) != 0)
                                {
                                        if (off_ta(8) != 0)
                                        {
                                                code_av = 40;
                                        }
                                }

                                GR5_Y = 1;
                        }
                }
                else
                {
                        GR5_Y = 0;
                }
        }

 // БЛОК работы с отказами

otkaz_read:


        // обращение к устройству, считывание сигналов

        if (num_AB == 0)
        {
                PMLC_select_device(RSV_PDEV, PDEV_1, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(NOM_PDEV, PDEV_1, &PMLC_TASK);
        }


        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_1, CMD_READ, 0, &(BCV04R_N.IO_PORT_1));

        otkaz_data = (~BCV04R_N.IO_PORT_1) & 0xF;


        // проверка наличия активного уровня сигналов
        if (otkaz_data == 0)
        {
                // сбрасываем признаки блокировки

                otk_g1 = 0;
                otk_g2 = 0;
                otk_h1 = 0;
                otk_h2 = 0;
        }
        else
        {

                // проверяем отказ Г1

                if ((otkaz_data & 0x1) != 0)
                {
                        // проверяем наличие блокировки сигнала от повторной отработки

                        if (otk_g1 == 0)
                        {
                                // ставим признак отработки сигнала

                                otk_g1 = 1;

                                // проверяем наличие питание соответствующего вентилятора

                                if ((tm_data_5 & 0xF) != 0)
                                {
                                        // достоверный отказ
                                        code_av = 129;

                                        g1_go = 1;
                                }
                                else
                                {
                                        // ложный отказ
                                        code_av = 133;
                                }
                        }
                }
                else
                {
                        // сбрасываем признак блокировки
                        otk_g1 = 0;
                }


                // проверяем отказ Г2

                if ((otkaz_data & 0x2) != 0)
                {
                        // проверяем наличие блокировки сигнала от повторной отработки

                        if (otk_g2 == 0)
                        {
                                // ставим признак отработки сигнала

                                otk_g2 = 1;

                                // проверяем наличие питание соответствующего вентилятора

                                if                                                                                                                                                                                                                                                                                                                                                                                              ((tm_data_5 & 0xF0) != 0)
                                {
                                        // достоверный отказ
                                        code_av = 130;

                                        g2_go = 1;
                                }
                                else
                                {
                                        // ложный отказ
                                        code_av = 134;
                                }
                        }
                }
                else
                {
                        // сбрасываем признак блокировки
                        otk_g2 = 0;
                }


                // проверяем отказ Х1

                if ((otkaz_data & 0x4) != 0)
                {
                        // проверяем наличие блокировки сигнала от повторной отработки

                        if (otk_h1 == 0)
                        {
                                // ставим признак отработки сигнала

                                otk_h1 = 1;

                                // проверяем наличие питание соответствующего вентилятора

                                if ((tm_data_6 & 0xF) != 0)
                                {
                                        // достоверный отказ
                                        code_av = 131;

                                        h1_go = 1;
                                }
                                else
                                {
                                        // ложный отказ
                                        code_av = 135;
                                }
                        }
                }
                else
                {
                        // сбрасываем признак блокировки
                        otk_h1 = 0;
                }


                // проверяем отказ Х2

                if ((otkaz_data & 0x8) != 0)
                {
                        // проверяем наличие блокировки сигнала от повторной отработки

                        if (otk_h2 == 0)
                        {
                                // ставим признак отработки сигнала

                                otk_h2 = 1;

                                // проверяем наличие питание соответствующего вентилятора

                                if ((tm_data_6 & 0xF0) != 0)
                                {
                                        // достоверный отказ
                                        code_av = 132;

                                        h2_go = 1;
                                }
                                else
                                {
                                        // ложный отказ
                                        code_av = 136;
                                }
                        }
                }
                else
                {
                        // сбрасываем признак блокировки
                        otk_h2 = 0;
                }
        }


otkaz_execute:

        // проверяем, что операция по вентиляторам в данный момент не производится

        if ((tim_25 == 0) && (tim_25_t == 0) && (tim_25_otk == 0))
        {
                // проверка на достижение максимума отказов

                if (count_otk_g < 4)
                {

                        // обработка неисправностей Г1

                        if (g1_go == 1)
                        {
                                // увеличиваем счётчик

                                count_otk_g = count_otk_g + 1;

                                // проверяем счётчик
                                if (count_otk_g < 4)
                                {
                                        ta_vozd = 255;

                                        // отключаем Г1
                                        otkl_kont_g1();

                                        // заводим таймер ожидания отключения вентилятора
                                        tim_25_otk = 1;
                                        count_tim_25_otk = 0;
                                        finish_25_otk = 0;
                                }
                                else
                                {
                                        g1_go = 0;

                                // формируем сигнал ОГК
                                        ogk_go = 1;
                                }

                                goto check_ogk_ohk;
                        }

                        // обработка неисправностей Г2

                        if (g2_go == 1)
                        {
                                // увеличиваем счётчик

                                count_otk_g = count_otk_g + 1;

                                // проверяем счётчик
                                if (count_otk_g < 4)
                                {
                                        ta_vozd = 255;

                                        // отключаем Г2
                                        otkl_kont_g2();

                                        // заводим таймер ожидания отключения вентилятора
                                        tim_25_otk = 1;
                                        count_tim_25_otk = 0;
                                        finish_25_otk = 0;
                                }
                                else
                                {
                                        g2_go = 0;

                                // формируем сигнал ОГК
                                        ogk_go = 1;
                                }

                                goto check_ogk_ohk;
                        }
                }

                // проверка на достижение максимума отказов

                if (count_otk_h < 4)
                {
                        // обработка неисправностей Х1

                        if (h1_go == 1)
                        {
                                // увеличиваем счётчик

                                count_otk_h = count_otk_h + 1;

                                // проверяем счётчик
                                if (count_otk_h < 4)
                                {
                                        ta_vozd = 255;

                                        // отключаем Х1
                                        otkl_kont_h1();

                                        // заводим таймер ожидания отключения вентилятора
                                        tim_25_otk = 1;
                                        count_tim_25_otk = 0;
                                        finish_25_otk = 0;
                                }
                                else
                                {
                                        h1_go = 0;

                                // формируем сигнал ОХК
                                        ohk_go = 1;
                                }

                                goto check_ogk_ohk;
                        }


                        // обработка неисправностей Х2

                        if (h2_go == 1)
                        {

                                // увеличиваем счётчик

                                count_otk_h = count_otk_h + 1;


                                        // проверяем счётчик
                                if (count_otk_h < 4)
                                {
                                        ta_vozd = 255;

                                        // отключаем Х2
                                        otkl_kont_h2();

                                        // заводим таймер ожидания отключения вентилятора
                                        tim_25_otk = 1;
                                        count_tim_25_otk = 0;
                                        finish_25_otk = 0;
                                }
                                else
                                {
                                        h2_go = 0;

                                // формируем сигнал ОХК
                                        ohk_go = 1;
                                }
                        }
                }

        check_ogk_ohk:

                // проверяем ОГК

                if (ogk_go == 1)
                {
                        code_av = 152;

                        ogk_go = 0;

                        ta_vozd = 255;

                        // отключаем ГОРЯЧИЙ КОНТУР

                        otkl_kontur_g();

                        // определяем параметры включения вентилятора в холодном контуре

                        if (h_fix == 0)
                        {
                                h_fix = 0x3;
                        }

                        ta_h = h_fix;

                        vent_gh_t = 1;

                        tim_25_t = 1;
                        count_tim_25_t = 0;
                        finish_25_t = 0;
                }

                // проверяем ОХК

                if (ohk_go == 1)
                {

                        code_av = 151;

                        ohk_go = 0;

                        ta_vozd = 255;

                        // отключаем холодный контур

                        otkl_kontur_h();

                        // определяем параметры включения вентилятора в горячем контуре

                        if (g_fix == 0)
                        {
                                g_fix = 0x3;
                        }

                        ta_g = g_fix;

                        vent_gh_t = 0;

                        tim_25_t = 1;
                        count_tim_25_t = 0;
                        finish_25_t = 0;
                }
        }


output_tm:

        status_uart = SP_STAT0;

        if ((status_uart & 0x40) != 0)
        {
                goto Yes_uart_data;
        }

        // чтение телеметрии токовых автоматов с портов

        // выбор комлект А, ПУ = 4
        PMLC_select_device(NOM_PDEV, PDEV_4, &PMLC_TASK);

        if (num_AB == 0)
        {
                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_2));
                tm_data_1 = ~BTA06R_AN.IO_PORT_2;

                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_3));
                tm_data_2 = ~BTA06R_AN.IO_PORT_3;
        }
        else
        {
                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_2));
                tm_data_3 = ~BTA06R_AN.IO_PORT_2;

                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_3));
                tm_data_4 = ~BTA06R_AN.IO_PORT_3;
        }


        // выбор комлект Б, ПУ = 4
        PMLC_select_device(RSV_PDEV, PDEV_4, &PMLC_TASK);

        if (num_AB == 0)
        {
                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_2));
                tm_data_3 = ~BTA06R_AN.IO_PORT_2;

                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_3));
                tm_data_4 = ~BTA06R_AN.IO_PORT_3;
        }
        else
        {
                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_2));
                tm_data_1 = ~BTA06R_AN.IO_PORT_2;

                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_READ, 0x00, &(BTA06R_AN.IO_PORT_3));
                tm_data_2 = ~BTA06R_AN.IO_PORT_3;
        }


        if (num_AB == 0)
        {
                PMLC_select_device(NOM_PDEV, PDEV_3, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(RSV_PDEV, PDEV_3, &PMLC_TASK);
        }

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
        tm_data_5 = ~BTA05R_AN.IO_PORT_2;


        if (num_AB == 0)
        {
                PMLC_select_device(NOM_PDEV, PDEV_2, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(RSV_PDEV, PDEV_2, &PMLC_TASK);
        }


        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
        tm_data_6 = ~BTA05R_AN.IO_PORT_2;


        if (num_AB == 0)
        {
                PMLC_select_device(RSV_PDEV, PDEV_2, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(NOM_PDEV, PDEV_2, &PMLC_TASK);
        }

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
        tm_data_7 = ~BTA05R_AN.IO_PORT_2;


        if (num_AB == 0)
        {
                PMLC_select_device(RSV_PDEV, PDEV_3, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(NOM_PDEV, PDEV_3, &PMLC_TASK);
        }

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_READ, 0x00, &(BTA05R_AN.IO_PORT_2));
        tm_data_8 = ~BTA05R_AN.IO_PORT_2;



        // формирование ТСК

        tsk_1 = 0;

        // Г1-2

        if ((tm_data_5 & 0xA) != 0)
        {
                tsk_1 = tsk_1 + 1;
        }

        if ((tm_data_5 & 0xA0) != 0)
        {
                tsk_1 = tsk_1 + 2;
        }

        // Х1-2

        if ((tm_data_6 & 0xA) != 0)
        {
                tsk_1 = tsk_1 + 4;
        }

        if ((tm_data_6 & 0xA0) != 0)
        {
                tsk_1 = tsk_1 + 8;
        }

        // БОКЗ

        if ((tm_data_7 & 0xA) != 0)
        {
                tsk_1 = tsk_1 + 16;
        }

        // ИКОР

        if ((tm_data_8 & 0xA) != 0)
        {
                tsk_1 = tsk_1 + 32;
        }

        // РИМС

        if ((tm_data_8 & 0xA0) != 0)
        {
                tsk_1 = tsk_1 + 64;
        }

        // ЭП1

        if ((tm_data_1 & 0xA) != 0)
        {
                tsk_1 = tsk_1 + 128;
        }


        tsk_2 = 0;

        // ЭП2

        if ((tm_data_1 & 0xA0) != 0)
        {
                tsk_2 = tsk_2 + 1;
        }

        // ЭП3

        if ((tm_data_2 & 0xA) != 0)
        {
                tsk_2 = tsk_2 + 2;
        }

        // ЭП4

        if ((tm_data_2 & 0xA0) != 0)
        {
                tsk_2 = tsk_2 + 4;
        }

        // ЭН-Х

        if ((tm_data_3 & 0xA) != 0)
        {
                tsk_2 = tsk_2 + 8;
        }


        // ЭН-Г

        if ((tm_data_3 & 0xA0) != 0)
        {
                tsk_2 = tsk_2 + 16;
        }

        // ЦПОВ

        if ((tm_data_4 & 0xA) != 0)
        {
                tsk_2 = tsk_2 + 32;
        }


        //      Формирование телеметрии

        // 1 = 1 + 2

        tm_1 = 0;

        // ЭП1 ОК

        if ((tm_data_1 & 0x3) == 0x3)
        {
                tm_1 = tm_1 + 1;
        }

        // ЭП1 РК

        if ((tm_data_1 & 0xC) == 0xC)
        {
                tm_1 = tm_1 + 2;
        }

        // ЭП2 ОК

        if ((tm_data_1 & 0x30) == 0x30)
        {
                tm_1 = tm_1 + 4;
        }

        // ЭП2 РК

        if ((tm_data_1 & 0xC0) == 0xC0)
        {
                tm_1 = tm_1 + 8;
        }

        // 2

        // ЭП3 ОК

        if ((tm_data_2 & 0x3) == 0x3)
        {
                tm_1 = tm_1 + 16;
        }

        // ЭП3 РК

        if ((tm_data_2 & 0xC) == 0xC)
        {
                tm_1 = tm_1 + 32;
        }

        // ЭП4 ОК

        if ((tm_data_2 & 0x30) == 0x30)
        {
                tm_1 = tm_1 + 64;
        }

        // ЭП4 РК

        if ((tm_data_2 & 0xC0) == 0xC0)
        {
                tm_1 = tm_1 + 128;
        }

        // 2 = 3 + 4.(1-3) + 7.(2)


        tm_2 = 0;

        // 3

        // ЭНХ ОК

        if ((tm_data_3 & 0x3) == 0x3)
        {
                tm_2 = tm_2 + 1;
        }

        // ЭНХ РК

        if ((tm_data_3 & 0xC) == 0xC)
        {
                tm_2 = tm_2 + 2;
        }

        // ЭНГ ОК

        if ((tm_data_3 & 0x30) == 0x30)
        {
                tm_2 = tm_2 + 4;
        }

        // ЭНГ РК

        if ((tm_data_3 & 0xC0) == 0xC0)
        {
                tm_2 = tm_2 + 8;
        }

        // 4

        // ЦПОВ ОК

        if ((tm_data_4 & 0x3) == 0x3)
        {
                tm_2 = tm_2 + 16;
        }

        // ЦПОВ РК

        if ((tm_data_4 & 0xC) == 0xC)
        {
                tm_2 = tm_2 + 32;
        }

        // РСЧ ОК

        if ((tm_data_7 & 0x30) == 0x30)
        {
                tm_2 = tm_2 + 64;
        }

        // РСЧ РК

        if ((tm_data_7 & 0xC0) == 0xC0)
        {
                tm_2 = tm_2 + 128;
        }



        // если проводится отключение вентилятора, то на время отключения телеметрию по ним не формируем

        if ((tim_25 != 0) || (tim_25_t != 0) || (tim_25_otk != 0))
        {
                goto format_tm4;
        }


        // 3 = 5 + 6

        tm_3 = 0;

        // и запоминаем информацию с контуров

        if (tm_data_5 != 0)
        {
                        // проверяем напряжение на выходе ТА

                if ((tm_data_5 & 0x55) != 0)
                {
                        // определяем состояние ТА для последнего работающего горячего вентилятора

                        g_fix = (tm_data_5 & 0x55) + ((tm_data_5 & 0x55) <<1);


                        // определяем дополнительную телеметрию

                        tm_3_dop_g = 0;

                        if ((tm_data_5 & 0x1) != 0)
                        {
                                tm_3_dop_g = tm_3_dop_g + 1;
                        }

                        if ((tm_data_5 & 0x4) != 0)
                        {
                                tm_3_dop_g = tm_3_dop_g + 2;
                        }

                        if ((tm_data_5 & 0x10) != 0)
                        {
                                tm_3_dop_g = tm_3_dop_g + 4;
                        }

                        if ((tm_data_5 & 0x40) != 0)
                        {
                                tm_3_dop_g = tm_3_dop_g + 8;
                        }

                }

                //  проверка - есть ли включённые вентиляторы Г1 на нагрузке

                if ((tm_data_5 & 0xA) != 0)
                {

                        if ((tm_data_5 & 0xA) != 0xA)
                        {
                                // на нагрузке 1 вентилятор - определяем какой именно

                                if ((tm_data_5 & 0x2) == 0x2)
                                {
                                        tm_3 = tm_3 + 1;

                                        hist_tr_g = 0;
                                }
                                else
                                {
                                        tm_3 = tm_3 + 2;

                                        hist_tr_g = 1;
                                }

                        }
                        else
                        {
                                // если младшие разряды отсутствует (при отключении на общую нагрузку)

                                if ((tm_data_5 & 0x5) == 0)
                                {

                                // если по нагрузке достоверно определить нельзя, то выводим старую телеметрию младших разрядов

                                        tm_3 = tm_3_dop_g + tm_3_dop_h;

                                }
                                else
                                {

                                // на нагрузке включены 2 вентилятора сразу - определяем по младшему разряду какой именно

                                        if ((tm_data_5 & 0x1) != 0)
                                        {
                                                tm_3 = tm_3 + 1;

                                                hist_tr_g = 0;
                                        }

                                        if ((tm_data_5 & 0x4) != 0)
                                        {
                                                tm_3 = tm_3 + 2;

                                                hist_tr_g = 1;
                                        }
                                }
                        }
                }


                //  проверка - есть ли включённые вентиляторы Г2 на нагрузке

                if ((tm_data_5 & 0xA0) != 0)
                {

                        if ((tm_data_5 & 0xA0) != 0xA0)
                        {
                                // на нагрузке 1 вентилятор - определяем какой именно

                                if ((tm_data_5 & 0x20) == 0x20)
                                {
                                        tm_3 = tm_3 + 4;

                                        hist_tr_g = 2;
                                }
                                else
                                {
                                        tm_3 = tm_3 + 8;

                                        hist_tr_g = 3;
                                }

                        }
                        else
                        {
                                // на нагрузке включены 2 вентилятора сразу - определяем по младшему разряду какой именно

                                if ((tm_data_5 & 0x50) == 0)
                                {

                                // если по нагрузке достоверно определить нельзя, то выводим старую телеметрию младших разрядов

                                        tm_3 = tm_3_dop_g + tm_3_dop_h;

                                }
                                else
                                {
                                        if ((tm_data_5 & 0x10) != 0)
                                        {
                                                tm_3 = tm_3 + 4;

                                                hist_tr_g = 2;
                                        }

                                        if ((tm_data_5 & 0x40) != 0)
                                        {
                                                tm_3 = tm_3 + 8;

                                                hist_tr_g = 3;
                                        }
                                }
                        }
                }
        }
        else
        {
                tm_3_dop_g = 0;
        }



        if (tm_data_6 != 0)
        {

                        // проверяем напряжение на выходе ТА

                if ((tm_data_6 & 0x55) != 0)
                {
                        // определяем состояние ТА для последнего работающего горячего вентилятора

                        h_fix = (tm_data_6 & 0x55) + ((tm_data_6 & 0x55) <<1);


                        // определяем дополнительную телеметрию

                        tm_3_dop_h = 0;

                        if ((tm_data_6 & 0x1) != 0)
                        {
                                tm_3_dop_h = tm_3_dop_h + 0x10;
                        }

                        if ((tm_data_6 & 0x4) != 0)
                        {
                                tm_3_dop_h = tm_3_dop_h + 0x20;
                        }

                        if ((tm_data_6 & 0x10) != 0)
                        {
                                tm_3_dop_h = tm_3_dop_h + 0x40;
                        }

                        if ((tm_data_6 & 0x40) != 0)
                        {
                                tm_3_dop_h = tm_3_dop_h + 0x80;
                        }
                }


                //  проверка - есть ли включённые вентиляторы Х1 на нагрузке

                if ((tm_data_6 & 0xA) != 0)
                {

                        if ((tm_data_6 & 0xA) != 0xA)
                        {
                                // на нагрузке 1 вентилятор - определяем какой именно

                                if ((tm_data_6 & 0x2) == 0x2)
                                {
                                        tm_3 = tm_3 + 16;

                                        hist_tr_h = 0;
                                }
                                else
                                {
                                        tm_3 = tm_3 + 32;

                                        hist_tr_h = 1;
                                }

                        }
                        else
                        {
                                // на нагрузке включены 2 вентилятора сразу - определяем по младшему разряду какой именно

                                if ((tm_data_6 & 0x5) == 0)
                                {

                                // если по нагрузке достоверно определить нельзя, то выводим старую телеметрию младших разрядов

                                        tm_3 = tm_3_dop_g + tm_3_dop_h;
                                }
                                else
                                {
                                        if ((tm_data_6 & 0x1) != 0)
                                        {
                                                tm_3 = tm_3 + 16;

                                                hist_tr_h = 0;
                                        }

                                        if ((tm_data_6 & 0x4) != 0)
                                        {
                                                tm_3 = tm_3 + 32;

                                                hist_tr_h = 1;
                                        }
                                }
                        }
                }


                //  проверка - есть ли включённые вентиляторы Х2 на нагрузке

                if ((tm_data_6 & 0xA0) != 0)
                {

                        if ((tm_data_6 & 0xA0) != 0xA0)
                        {
                                // на нагрузке 1 вентилятор - определяем какой именно

                                if ((tm_data_6 & 0x20) == 0x20)
                                {
                                        tm_3 = tm_3 + 64;

                                        hist_tr_h = 2;
                                }
                                else
                                {
                                        tm_3 = tm_3 + 128;

                                        hist_tr_h = 3;
                                }

                        }
                        else
                        {
                                // на нагрузке включены 2 вентилятора сразу - определяем по младшему разряду какой именно

                                if ((tm_data_6 & 0x50) == 0)
                                {

                                        // если по нагрузке достоверно определить нельзя, то выводим старую телеметрию младших разрядов

                                        tm_3 = tm_3_dop_g + tm_3_dop_h;
                                }
                                else
                                {
                                        if ((tm_data_6 & 0x10) != 0)
                                        {
                                                tm_3 = tm_3 + 64;

                                                hist_tr_h = 2;
                                        }

                                        if ((tm_data_6 & 0x40) != 0)
                                        {
                                                tm_3 = tm_3 + 128;

                                                hist_tr_h = 3;
                                        }
                                }
                        }
                }
        }
        else
        {
                tm_3_dop_h = 0;
        }


format_tm4:

        // 4 = 7.1 + 8.1 + 8.2 + 4.2

        tm_4 = 0;

        // 7.1     БОКЗ

        if ((tm_data_7 & 0x3) == 0x3)
        {
                tm_4 = tm_4 + 1;
        }

        if ((tm_data_7 & 0xC) == 0xC)
        {
                tm_4 = tm_4 + 2;
        }

        // 8.1       ИКОР

        if ((tm_data_8 & 0x3) == 0x3)
        {
                tm_4 = tm_4 + 4;
        }

        if ((tm_data_8 & 0xC) == 0xC)
        {
                tm_4 = tm_4 + 8;
        }


  //      8.2       РИМС

        if ((tm_data_8 & 0x30) == 0x30)
        {
                tm_4 = tm_4 + 16;
        }

        if ((tm_data_8 & 0xC0) == 0xC0)
        {
                tm_4 = tm_4 + 32;
        }

        //  4.2    ЭНГГАК

        if ((tm_data_4 & 0x30) == 0x30)
        {
                tm_4 = tm_4 + 64;
        }

        if ((tm_data_4 & 0xC0) == 0xC0)
        {
                tm_4 = tm_4 + 128;
        }


        // при первом опросе предыдущая телеметрия приравнивается к текущей

        if (first_vkl == 1)
        {
                first_vkl = 0;

                tm_1_p = tm_1;
                tm_2_p = tm_2;
                tm_3_p = tm_3;
                tm_4_p = tm_4;

                tm_1_l = tm_1;
                tm_2_l = tm_2;
                tm_3_l = tm_3;
                tm_4_l = tm_4;

                goto Main_cycle;
        }


        if (tm_1_l != tm_1)
        {

                if (ta_vozd == 0)
                {
                        change_tm_1();
                }

                tm_1_l = tm_1;
        }


        if (tm_2_l != tm_2)
        {

                if (ta_vozd == 0)
                {
                        change_tm_2();
                }

                tm_2_l = tm_2;
        }


        if (tm_3_l != tm_3)
        {

                if (ta_vozd == 0)
                {
                        change_tm_3();
                }

                tm_3_l = tm_3;
        }


        if (tm_4_l != tm_4)
        {

                if (ta_vozd == 0)
                {
                        change_tm_4();
                }

                tm_4_l = tm_4;
        }


        // анализ расхождения текущей телетрии с предшествующей и входа в режим изменений

        // проверяем, что нет режима аварийного сообщения

        if (mode_tm != 5)
        {
                // если уже режим изменений и другой (5) кадр, то ждём завершения 5 сек

                if ((mode_tm == 2) && (frame_tm == 5))
                {
                        goto analiz_frame5;
                }
                else
                {
                        // иначе сравниваем старую телеметрию с новой

                        if ((tm_2_p != tm_2) || (tm_3_p != tm_3))
                        {
                                tm_2_p = tm_2;

                                tm_3_p = tm_3;

                                // меняем текущий фрейм на 6 и входим в режим изменений

                                frame_tm = 6;

                                set_mode2();
                        }
                }

analiz_frame5:

                // если уже режим изменений и другой (6) кадр, то ждём завершения 5 сек

                if ((mode_tm == 2) && (frame_tm == 6))
                {
                        goto analiz_reload;
                }
                else
                {
                        // иначе сравниваем старую телеметрию с новой

                        if ((tm_1_p != tm_1) || (tm_4_p != tm_4))
                        {

                                tm_1_p = tm_1;

                                tm_4_p = tm_4;

                                // меняем текущий фрейм на 5 и входим в режим изменений

                                frame_tm = 5;

                                set_mode2();
                        }
                }
        }


analiz_reload:

        // обрабатываем признак срабатывания таймера, перзагуржаем таймер и меняем режим телеметрии (если нужно).

        if (change_tm == 255)
        {

                change_tm = 0;


                // перезагрузка счётчика по первому  режиму

                if (mode_tm == 1)
                {

                        frame_tm = frame_tm + 1;

                        // переход с 6 фрейма на 1

                        if (frame_tm > 6)
                        {
                                frame_tm = 1;
                        }

                        set_mode1();
                }

                 // возврат в первый режим после работы во 2-м

                 if ((mode_tm == 2) && (last_mode_tm == 1))
                 {

                        frame_tm = frame_tm + 1;

                        if (frame_tm > 6)
                        {
                                frame_tm = 1;
                        }

                        set_mode1();
                }

                // выход из 2 режима и возврат в 4

                if ((mode_tm == 2) && (last_mode_tm == 4))
                {

                        frame_tm = frame_tm + 1;

                        if (frame_tm > 6)
                        {
                                frame_tm = 1;
                        }

                        last_mode_tm = 2;

                        mode_tm = 4;

                        count_timer = 0;
                        timer_lim = timer27;
                }


                // перезагрузка счётчика по 4 режиму

                if (mode_tm == 4)
                {

                        count_timer = 0;

                        if (count_mode3 < 12)
                        {
                                count_mode3 = count_mode3 + 1;
                        }

                        // смена кадра с аварии на другой по списку

                        if (frame_tm == 7)
                        {

                                frame_tm = save_frame + 1;

                                if (frame_tm > 6)
                                {
                                        frame_tm = 1;
                                }

                                if (count_mode3 < 12)
                                {
                                        timer_lim = timer5;
                                }
                                else
                                {
                                        timer_lim = timer27;
                                }
                        }
                        else
                        {
                                //  смена на аварийное сообщение

                                save_frame = frame_tm;
                                frame_tm = 7;

                                timer_lim = timer5;
                        }
                }


                // перезагрузка счётчика по 5 режиму

                if (mode_tm == 5)
                {
                        count_timer = 0;
                        timer_lim = timer27;
                }


                // для режима полной телеметрии

                if (mode_tm == 6)
                {
                        frame_pt = frame_pt + 1;

                        if (frame_pt > 15)
                        {
                                frame_pt = 1;

                        }

                        count_timer = 0;
                        timer_lim = timer5;

                }
        }


        // блок вывода телеметрии

        // выдача телеметрии и ТСК по SPI - выбор и инициализация устройства

        if (num_AB == 0)
        {
                PMLC_select_device(NOM_PDEV, PDEV_1, &PMLC_TASK);
        }
        else
        {
                PMLC_select_device(RSV_PDEV, PDEV_1, &PMLC_TASK);
        }




        // 2 разные схемы

        // Схема обычной телеметрии , mode_tm = 1-5, 7 параметров


        if (mode_tm < 5)
        {


        // TD 1

                if (frame_tm == 1)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, tips_td + 0x18, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~dig_td[1][td1 - 1], &(BCV03R_N.IO_PORT_4));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ~dig_td[0][td1 - 1], &(BCV03R_N.IO_PORT_3));
                }

                // TD 2

                if (frame_tm == 2)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, tips_td + 0x18, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~dig_td[1][3 + td2 - 1], &(BCV03R_N.IO_PORT_4));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ~dig_td[0][3 + td2 - 1], &(BCV03R_N.IO_PORT_3));

                }

                // TD 3

                if (frame_tm == 3)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, tips_td + 0x18, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~dig_td[1][6 + td3 - 1], &(BCV03R_N.IO_PORT_4));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ~dig_td[0][6 + td3 - 1], &(BCV03R_N.IO_PORT_3));
                }


                // TD 4

                if (frame_tm == 4)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, tips_td + 0x18, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~dig_td[1][9 + td4 - 1], &(BCV03R_N.IO_PORT_4));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ~dig_td[0][9 + td4 - 1], &(BCV03R_N.IO_PORT_3));
                }

                // TA 1

                if (frame_tm == 5)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0x10, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, tm_4, &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, tm_1, &(BCV03R_N.IO_PORT_4));
                }

                // TA 2

                if (frame_tm == 6)
                {
                        if (alg == 1)
                        {
                                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0xA, &(BCV03R_N.IO_PORT_2));
                        }
                        else
                        {
                                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0x8, &(BCV03R_N.IO_PORT_2));
                        }

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, tm_2, &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, tm_3, &(BCV03R_N.IO_PORT_4));
                }

                // avaria

                if (frame_tm == 7)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ((mas_tm_otkaz[(count_otk_g & 0x7)] << 3) + mas_tm_otkaz[(count_otk_h & 0x7)]), &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~code_av, &(BCV03R_N.IO_PORT_4));
                }
        }


        if (mode_tm == 5)
        {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ((mas_tm_otkaz[(count_otk_g & 0x7)] << 3) + mas_tm_otkaz[(count_otk_h & 0x7)]), &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~code_av, &(BCV03R_N.IO_PORT_4));
        }


        if (mode_tm == 6)
        {

                // режим полной телеметрии, 15 параметров

                if ((frame_pt >= 1) & (frame_pt <=12 ))
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, tips_td + 0x18, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~dig_td[1][frame_pt - 1], &(BCV03R_N.IO_PORT_4));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ~dig_td[0][frame_pt - 1], &(BCV03R_N.IO_PORT_3));

                }

                if (frame_pt == 13)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0x10, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, tm_4, &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, tm_1, &(BCV03R_N.IO_PORT_4));
                }

                if (frame_pt == 14)
                {

                        if (alg == 1)
                        {
                                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0xA, &(BCV03R_N.IO_PORT_2));
                        }
                        else
                        {
                                PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0x8, &(BCV03R_N.IO_PORT_2));
                        }

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, tm_2, &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, tm_3, &(BCV03R_N.IO_PORT_4));
                }

                if (frame_pt == 15)
                {
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_2, CMD_WRITE, 0, &(BCV03R_N.IO_PORT_2));

                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_3, CMD_WRITE, ((mas_tm_otkaz[(count_otk_g & 0x7)] << 3) + mas_tm_otkaz[(count_otk_h & 0x7)]), &(BCV03R_N.IO_PORT_3));
                        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_4, CMD_WRITE, ~code_av, &(BCV03R_N.IO_PORT_4));
                }

        }




        // проверка возникновения новой аварийной ситуации

        // при нахождении в режиме 2, 5,6 вход в режим 4 не осуществляется

        if ((mode_tm == 1) || (mode_tm == 4))
        {

                if (code_av != code_av_last)
                {
                        code_av_last = code_av;

                        if (code_av != 0)
                        {
                                if (mode_tm != 4)
                                {
                                        last_mode_tm = mode_tm;
                                }

                                mode_tm = 4;

                                save_frame = frame_tm;

                                frame_tm = 7;

                                change_tm = 0;
                                count_timer = 0;

                                count_mode3 = 0;

                                timer_lim = timer5;
                        }
                }
        }

        // вывод ТСК

        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_0, CMD_WRITE, tsk_2, &(BCV03R_N.IO_PORT_0));
        PMLC_cmd_exec(&PMLC_TASK, ADDR_IO_PORT_1, CMD_WRITE, tsk_1, &(BCV03R_N.IO_PORT_1));



        // включение вентялятора по команде

check_25_second:

        if (tim_25 == 1)
        {
                // проверяем, что ВСЕ другие вентиляторы выключены

                if ((tm_data_5 == 0) && (tm_data_6 == 0) && (count_tim_25 > 335))
                {
                        // сброс таймера ожидания

                        tim_25 = 0;
                        finish_25 = 0;

                        count_tim_25 = 0;

                        tm_3 = 0;

                        // ставим признак воздействи на ТА

                        ta_vozd = 255;

                        // выполняем команду включения

                        if (vent_gh == 0)
                        {
                                ta_g = g_com;

                                kontur_g();

                                GR26_27 = 0;
                        }

                        if (vent_gh == 1)
                        {
                                ta_h = h_com;

                                kontur_h();

                                GR20_19 = 0;
                        }

                        goto output_tm;
                }
                else
                {
                        // если доп.время отключения истекло, а напряжение не снялось, то формируем аварийное сообщение

                        if (finish_25 == 1)
                        {
                                tim_25 = 0;
                                finish_25 = 0;

                                count_tim_25 = 0;

                                // эта ветка для случая, когда команда Откл. Г2 РК
                                if (vent_gh == 2)
                                {
                                        if ((tm_data_5 & 0xc0) != 0)
                                        {
                                                code_av = 50;
                                        }
                                }
                                else
                                {
                                        analiz_vent_err();
                                }
                        }
                }
        }


// включение вентилятора по температуре

check_25_second_temp:

        if (tim_25_t == 1)
        {
                // проверяем, что ВСЕ другие вентиляторы выключены

                if ((tm_data_5 == 0) && (tm_data_6 == 0) && (count_tim_25_t > 335))
                {

                        tim_25_t = 0;
                        finish_25_t = 0;

                        count_tim_25_t = 0;

                        tm_3 = 0;

                        // установка признака воздействия

                        ta_vozd = 255;

                        // выполняем команду включения

                        if (vent_gh_t == 0)
                        {
                                if (g_fix != 0)
                                {
                                        ta_g = g_fix;
                                }
                                else
                                {
                                        ta_g = 0x3;
                                }

                                if (ish_g == 1)
                                {
                                        ta_g = 0x3;

                                        ish_g = 0;
                                }

                                kontur_g();
                        }
                        else
                        {
                                if (h_fix != 0)
                                {
                                        ta_h = h_fix;
                                }
                                else
                                {
                                        ta_h = 0x3;
                                }

                                if (ish_h == 1)
                                {
                                        ta_h = 0x3;

                                        ish_h = 0;
                                }

                                kontur_h();
                        }

                        goto output_tm;
                }
                else
                {
                        // если время отключения истекло, а напряжение не снялось, то формируем аварийное сообщение

                        if (finish_25_t == 1)
                        {
                                tim_25_t = 0;
                                finish_25_t = 0;

                                count_tim_25_t = 0;

                                analiz_vent_err();
                        }
                }
        }


// включение вентилятора по отказам

check_25_second_otk:

        if (tim_25_otk == 1)
        {
                // проверяем, что ВСЕ другие вентиляторы выключены

                if ((tm_data_5 == 0) && (tm_data_6 == 0) && (count_tim_25_otk > 335))
                {
                        tim_25_otk = 0;
                        finish_25_otk = 0;

                        count_tim_25_otk = 0;

                        tm_3 = 0;

                        // включаем нужный вентилятор в зависимости от типа отказа

                        if (g1_go == 1)
                        {
                                g1_go = 0;

                                vkl_kont_g2();

                                goto set_vozd_ta;
                        }

                        if (g2_go == 1)
                        {
                                g2_go = 0;

                                vkl_kont_g1();

                                goto set_vozd_ta;
                        }

                        if (h1_go == 1)
                        {
                                h1_go = 0;

                                vkl_kont_h2();

                                goto set_vozd_ta;
                        }

                        if (h2_go == 1)
                        {
                                h2_go = 0;

                                vkl_kont_h1();
                        }

set_vozd_ta:
                        // воздействие на ТА

                        ta_vozd = 255;

                        goto output_tm;

                }
                else
                {
                        // если время отключения истекло, а напряжение не снялось, то формируем аварийное сообщение

                        if (finish_25_otk == 1)
                        {
                                tim_25_otk = 0;
                                finish_25_otk = 0;

                                count_tim_25_otk = 0;

                                g1_go = 0;
                                g2_go = 0;
                                h1_go = 0;
                                h2_go = 0;

                                analiz_vent_err();
                        }
                }
        }




// БЛОК работы с МКО

check_mko:

        // Обработка прерывания по МКО

        if (bsi_int == 1)
        {
                bsi_int = 0;


                // считываем код команды и записываем её в буфер

                if ((bsi_rt_stat & 0x400) == 0)
                {


                        // чтение информации БШВ
                        // 5 подадрес

                        bshv1 = *(volatile unsigned short*)(0x842 + 0x40 * 4);  // СД 0 - младший байт

                        if (bshv1_prev != bshv1)
                        {
                                bshv2 = *(volatile unsigned short*)(0x843 + 0x40 * 4);  // СД 0 - старший байт

                                bshv3 = *(volatile unsigned short*)(0x844 + 0x40 * 4);  // СД 1 - младший байт
                                bshv4 = *(volatile unsigned short*)(0x845 + 0x40 * 4);  // СД 1 - старший байт

                                bshv1_prev = bshv1;

                                c_msg_bshv ++;

                        }


                        // Приём и обработка ПК

                        // чтение ПК - 1 подадрес , СД 0

                        // счтываем код команды ПК

                        mko_in_l = *(volatile unsigned short*)(0x842);
                        mko_in_h = *(volatile unsigned short*)(0x843);



                  //      mko_in_h = mko_in_h & 0x3;

                                // проверяем что есть команда
                        if ((mko_in_l == 0) && (mko_in_h == 0))
                        {

                                __NOP();

                        }
                        else
                        {

                                if  (mko_in_h <= 0x3)
                                {


                                        // проверяем - внутренняя ли команда ТР
                                        // если более 936, то внутренняя

                                        if ((mko_in_l > 167) && (mko_in_h == 3))
                                        {
                                                prog_com = mko_in_l - 167;

                                                fl_com = 0;

                                        // сохраняем код последней ПК для телеметрии

                                                last_pc = 256 * mko_in_h + mko_in_l;

                                        }
                                        else
                                        {
                                                // добавляем команду МКО в буффер

                                                add_mko_buffer();

                                                last_tr_in = 256 * mko_in_h + mko_in_l;

                                                count_tr_in ++;

                                                if (count_tr_in >= 64)
                                                {
                                                        count_tr_in = 0;
                                                }
                                        }

                                        // увеличиваем счётчик приёмных комманж
                                        c_msg_pc ++;
                                }

                                // обнуляем приёмный буфер МКО

                                for (io = 0; io <= 2; io++)
                                {
                                        *(volatile unsigned short*)(0x842 + io) = 0;
                                }
                        }
                }
        }


telem_mko:

        // транзитные данные БШВ

        tmi[0] = 256 * bshv2 + bshv1;
        tmi[1] = 256 * bshv4 + bshv3;

        // Состояние ТР (пока пустое)

        tmi[2] = 256 * (count_tr_in << 2) + last_tr_in;
        tmi[3] = 256 * (count_tr_out << 2) + last_tr_out;

        //  код команды + её флаг, флаг = 0 - выполнена, 2048 - выполняется, 4096 - выполнена с ошибкой
        //  флаг меняется по ходу приёма и выполнения команд

        tmi[4] = last_pc + fl_com;

        // счётчик принятых сообщений

        tmi[5] = c_msg_bshv;
        tmi[6] = c_msg_pc;


        // 7 СД - Режимы управления ТД

        tmi[7] = ((num_AB & 0x1) * 128 + 32 * ruch_mode + 64 * alg) * 256;

        if (avt_mode2 == 0)
        {
                tmi[7] = tmi[7] + 256 * 16;
        }
        else
        {
                tmi[7] = tmi[7] + 256 * 2;
        }


        if (ruch_mode == 1)
        {
                tmi[7] = tmi[7] + 256 * 4;

        }
        else
        {
                if (avt_mode1 == 3)
                {
                        tmi[7] = tmi[7] + 256 * 1;
                }

                if (avt_mode1 == 1)
                {
                        tmi[7] = tmi[7] + 256 * 8;
                }

                if (avt_mode1 == 0)
                {
                        tmi[7] = tmi[7] + 256 * 4;
                }
        }

        tmi[7] = tmi[7] + (mode_td * 128) + (count_otk_h <<3) + count_otk_g;


        // СД 8 - ТА

        tmi[8] = tm_1 + tm_2 * 256;

        // СД 9 - ТА

        tmi[9] = tm_3 + ((tm_4 & 0xC3) + ((tm_4 & 0x0C) << 2) + ((tm_4 & 0x30) >> 2)) * 256;


        // СД 10 - выбранные ТД

        if (td1 != 3)
        {
                tmi[10] = td1 * 256;
        }
        else
        {
                tmi[10] = 4 * 256;
        }


        if (td2 == 1)
        {
                tmi[10] = tmi[10] + 16 * 256;
        }
        if (td2 == 2)
        {
                tmi[10] = tmi[10] + 32 * 256;
        }
        if (td2 == 3)
        {
                tmi[10] = tmi[10] + 64 * 256;
        }


        if (td3 != 3)
        {
                tmi[10] = tmi[10] + td3;
        }
        else
        {
                tmi[10] = tmi[10] + 4;
        }


        if (td4 == 1)
        {
                tmi[10] = tmi[10] + 16;
        }
        if (td4 == 2)
        {
                tmi[10] = tmi[10] + 32;
        }
        if (td4 == 3)
        {
                tmi[10] = tmi[10] + 64;
        }


        // СД 11 - блокированные ТД

        tmi[11] = 0;

        if (bl_td[6] == 255)
        {
                tmi[11] = tmi[11] + 1;
        }

        if (bl_td[7] == 255)
        {
                tmi[11] = tmi[11] + 2;
        }

        if (bl_td[8] == 255)
        {
                tmi[11] = tmi[11] + 4;
        }


        if (bl_td[9] == 255)
        {
                tmi[11] = tmi[11] + 16;
        }

        if (bl_td[10] == 255)
        {
                tmi[11] = tmi[11] + 32;
        }

        if (bl_td[11] == 255)
        {
                tmi[11] = tmi[11] + 64;
        }


        if (bl_td[0] == 255)
        {
                tmi[11] = tmi[11] + 1 * 256;
        }

        if (bl_td[1] == 255)
        {
                tmi[11] = tmi[11] + 2 * 256;
        }

        if (bl_td[2] == 255)
        {
                tmi[11] = tmi[11] + 4 * 256;
        }


        if (bl_td[3] == 255)
        {
                tmi[11] = tmi[11] + 16 * 256;
        }

        if (bl_td[4] == 255)
        {
                tmi[11] = tmi[11] + 32 * 256;
        }

        if (bl_td[5] == 255)
        {
                tmi[11] = tmi[11] + 64 * 256;
        }

        // код последней выполненной команды

        if (num_com == 255)
        {
                tmi[12] = 256 * (inf_bvm + 0) + 0;
        }
        else
        {
                if (num_com < 71)
                {
                        prog_com_tm = num_com + 168;
                }

                if (prog_com_tm == 0)
                {
                        tmi[12] = 256 * (inf_bvm + 0) + 0;
                }
                else
                {
                        tmi[12] = 256 * (inf_bvm + 3) + prog_com_tm;
                }
        }



        //  количество оставшихся импульсов

        tmi[13] = code_av;


        // 14-25 СД   - температура на 12 ТД

        for (io = 0; io <=11; io++)
        {
                tmi[14 + io] = dig_td[1][io];

                // уточняем знак

                if (t_td[io] >=0)
                {
                        tmi[14 + io] = tmi[14 + io] + 256;
                }
        }

        // KS

        ks_tmi = 0;

        for (i = 0; i <=25; i++)
        {


                ks_tmi = ks_tmi + tmi[i];

                if (ks_tmi > 0xFFFF)
                {
                        ks_tmi = (ks_tmi & 0xFFFF);

                        ks_tmi = ks_tmi + 1;
                }
        }


        for (i = 0; i < 31; i++)
        {
              *(volatile unsigned short*)(0x1042 + 0x40 + i*2) = tmi[i];
        }

        *(volatile unsigned short*)(0x1040 + 0x40) = ks_tmi;


        // KS

        // E0FE, 7F41

 //       iok[30] = (ks_iok & 0xFFFF) + ((ks_iok & 0xFFFF0000) >> 16);


        // возврат на начало основного цикла

        goto Main_cycle;


// отдельный блок выдачи градусов по последовательному  каналу при работе с КПА

Send12_td:

        delay_uart = 0;

        delay_7000();

        i = 0;

        while (i <= 11)
        {
                delay_uart = 0;

Send_num_td_45:

                t = cod_td[i];

                status_uart = SP_STAT0;

                if (( status_uart & 0x8) != 0)
                {
                        SBUF_TX0 = t;
                        __NOP();

                        i = i + 1;
                }
                else
                {
                        delay_uart = delay_uart + 1;
                        __NOP();
                        __NOP();
                        __NOP();

                        if (delay_uart > 32000)
                        {
                                goto Fin_send_45;
                        }
                }
        }

Fin_send_45:

        goto Main_cycle;

}






